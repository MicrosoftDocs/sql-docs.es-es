---
description: Función SQLGetInfo
title: SQLGetInfo (función) | Microsoft Docs
ms.custom: ''
ms.date: 05/28/2020
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: reference
apiname:
- SQLGetInfo
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLGetInfo
helpviewer_keywords:
- SQLGetInfo function [ODBC]
ms.assetid: 49dceccc-d816-4ada-808c-4c6138dccb64
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: c8ef573f639e10f8b3d0d3c5c1276bcc14a8a378
ms.sourcegitcommit: 33f0f190f962059826e002be165a2bef4f9e350c
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/30/2021
ms.locfileid: "99180970"
---
# <a name="sqlgetinfo-function"></a>Función SQLGetInfo

**Conformidad**  
 Versión introducida: compatibilidad con estándares de ODBC 1,0: ISO 92  
  
 **Resumen**  
 **SQLGetInfo** devuelve información general sobre el controlador y el origen de datos asociado a una conexión.  
  
## <a name="syntax"></a>Sintaxis  
  
```cpp  
  
SQLRETURN SQLGetInfo(  
     SQLHDBC         ConnectionHandle,  
     SQLUSMALLINT    InfoType,  
     SQLPOINTER      InfoValuePtr,  
     SQLSMALLINT     BufferLength,  
     SQLSMALLINT *   StringLengthPtr);  
```  
  
## <a name="arguments"></a>Argumentos  

 *ConnectionHandle*  
 [Entrada] Identificador de conexión.  
  
 *InfoType*  
 Entradas Tipo de información.  
  
 *InfoValuePtr*  
 Genere Puntero a un búfer en el que se va a devolver la información. En función de la *InfoType* solicitada, la información devuelta será una de las siguientes: una cadena de caracteres terminada en null, un valor de SQLUSMALLINT, una máscara de bits sqluinteger que incluya, una marca sqluinteger que incluya, un valor binario de sqluinteger que incluya o un valor SQLULEN.  
  
 Si el argumento *InfoType* es SQL_DRIVER_HDESC o SQL_DRIVER_HSTMT, el argumento *InfoValuePtr* es Input y output. (Consulte los descriptores de SQL_DRIVER_HDESC o SQL_DRIVER_HSTMT más adelante en esta descripción de la función para obtener más información).  
  
 Si *InfoValuePtr* es null, *StringLengthPtr* devolverá el número total de bytes (sin incluir el carácter de terminación null para los datos de caracteres) disponible para devolver en el búfer señalado por *InfoValuePtr*.  
  
 *BufferLength*  
 Entradas Longitud del búfer de \* *InfoValuePtr* . Si el valor de *\* InfoValuePtr* no es una cadena de caracteres o si *InfoValuePtr* es un puntero nulo, se omite el argumento *BufferLength* . El controlador supone que el tamaño de *\* INFOVALUEPTR* es SQLUSMALLINT o sqluinteger que incluya, basado en *InfoType*. Si *\* InfoValuePtr* es una cadena Unicode (cuando se llama a **SQLGetInfoW**), el argumento *BufferLength* debe ser un número par; si no es así, se devuelve SQLSTATE HY090 (longitud de búfer o cadena no válida).  
  
 *StringLengthPtr*  
 Genere Puntero a un búfer en el que se va a devolver el número total de bytes (sin incluir el carácter de terminación null para los datos de caracteres) disponible para devolver en **InfoValuePtr*.  
  
 En el caso de los datos de caracteres, si el número de bytes disponibles para devolver es mayor o igual que *BufferLength*, la información de \* *InfoValuePtr* se trunca en *BufferLength* bytes menos la longitud de un carácter de terminación NULL y el controlador termina en NULL.  
  
 En el caso de todos los demás tipos de datos, se omite el valor de *BufferLength* y el controlador asume que el tamaño de \* *INFOVALUEPTR* es SQLUSMALLINT o sqluinteger que incluya, en función de la *InfoType*.  
  
## <a name="returns"></a>Devoluciones  

 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR o SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Diagnóstico  

 Cuando **SQLGetInfo** devuelve SQL_ERROR o SQL_SUCCESS_WITH_INFO, se puede obtener un valor SQLSTATE asociado llamando a **SQLGetDiagRec** con un *HandleType* de SQL_HANDLE_DBC y un *identificador* de *ConnectionHandle*. En la tabla siguiente se enumeran los valores de SQLSTATE que suele devolver **SQLGetInfo** y se explica cada uno de ellos en el contexto de esta función. la notación "(DM)" precede a las descripciones de SQLSTATEs devueltas por el administrador de controladores. El código de retorno asociado a cada valor SQLSTATE es SQL_ERROR, a menos que se indique lo contrario.  
  
|SQLSTATE|Error|Descripción|  
|--------------|-----------|-----------------|  
|01000|ADVERTENCIA general|Mensaje informativo específico del controlador. (La función devuelve SQL_SUCCESS_WITH_INFO).|  
|01004|Datos de cadena, truncados a la derecha|El búfer \* *InfoValuePtr* no era lo suficientemente grande como para devolver toda la información solicitada. Por lo tanto, la información se truncó. La longitud de la información solicitada en su forma no truncada se devuelve en **StringLengthPtr*. (La función devuelve SQL_SUCCESS_WITH_INFO).|  
|08003|Conexión no abierta|(DM) el tipo de información solicitada en *InfoType* requiere una conexión abierta. De los tipos de información reservados por ODBC, solo se pueden devolver SQL_ODBC_VER sin una conexión abierta.|  
|08S01|Error de vínculo de comunicación|Se produjo un error en el vínculo de comunicación entre el controlador y el origen de datos al que se conectó el controlador antes de que la función finalizara el procesamiento.|  
|HY000|Error general|Se produjo un error para el que no había ningún SQLSTATE específico y para el que no se definió ningún SQLSTATE específico de la implementación. El mensaje de error devuelto por **SQLGetDiagRec** en el búfer *\* MessageText* describe el error y su causa.|  
|HY001|Error de asignación de memoria|El controlador no pudo asignar memoria necesaria para admitir la ejecución o la finalización de la función.|  
|HY010|Error de secuencia de función|Se llamó a **SQLExecute**, **SQLExecDirect** o **SQLMoreResults** para *StatementHandle* y se devolvió SQL_PARAM_DATA_AVAILABLE. Se llamó a esta función antes de recuperar los datos de todos los parámetros transmitidos por secuencias.|  
|HY013|Error de administración de memoria|No se pudo procesar la llamada de función porque no se pudo tener acceso a los objetos de memoria subyacentes, posiblemente debido a condiciones de memoria insuficientes.|  
|HY024|Valor de atributo no válido|(DM) el argumento *InfoType* se SQL_DRIVER_HSTMT y el valor al que apunta *InfoValuePtr* no era un identificador de instrucción válido.<br /><br /> (DM) el argumento *InfoType* se SQL_DRIVER_HDESC y el valor al que apunta *InfoValuePtr* no era un identificador de descriptor válido.|  
|HY090|Longitud de búfer o cadena no válida|(DM) el valor especificado para el argumento *BufferLength* era menor que 0.<br /><br /> (DM) el valor especificado para *BufferLength* era un número impar y *\* InfoValuePtr* era de un tipo de datos Unicode.|  
|HY096|Tipo de información fuera del intervalo|El valor especificado para el argumento *InfoType* no era válido para la versión de ODBC admitida por el controlador.|  
|HY117|La conexión se suspendió debido a un estado de transacción desconocido. Solo se permiten las funciones de desconexión y de solo lectura.|(DM) para obtener más información sobre el estado suspendido, consulte [función SQLEndTran](sqlendtran-function.md).|  
|HYC00|Campo opcional no implementado|El valor especificado para el argumento *InfoType* era un valor específico del controlador que no es compatible con el controlador.|  
|HYT01|Tiempo de espera de conexión agotado|Expiró el tiempo de espera de conexión antes de que el origen de datos respondiera a la solicitud. El período de tiempo de espera de la conexión se establece mediante **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|El controlador no admite esta función|(DM) el controlador que corresponde a *ConnectionHandle* no admite la función.|  
  
## <a name="comments"></a>Comentarios  

 Los tipos de información definidos actualmente se muestran en "tipos de información", más adelante en esta sección. se espera que se defina más para aprovechar los distintos orígenes de datos. ODBC reserva un intervalo de tipos de información; los programadores de controladores deben reservar valores para su propio uso específico del controlador desde Open Group. **SQLGetInfo** no realiza ninguna conversión Unicode ni código *thunk* (vea [el Apéndice A: códigos de error ODBC](../appendixes/appendix-a-odbc-error-codes.md) de la *Referencia del programador de ODBC*) para *InfoTypes* definidos por el controlador. Para obtener más información, vea [tipos de datos específicos del controlador, tipos de descriptores, tipos de información, tipos de diagnóstico y atributos](../develop-app/driver-specific-data-types-descriptor-information-diagnostic.md). El formato de la información devuelta en \* *InfoValuePtr* depende de la *InfoType* solicitada. **SQLGetInfo** devolverá información en uno de los cinco formatos diferentes:  
  
- Una cadena de caracteres terminada en null  
  
- Un valor de SQLUSMALLINT  
  
- Una máscara de SQLUINTEGER que incluya  
  
- Un valor de SQLUINTEGER que incluya  
  
- Un valor binario de SQLUINTEGER que incluya  
  
 El formato de cada uno de los siguientes tipos de información se indica en la descripción del tipo. La aplicación debe convertir el valor devuelto en **InfoValuePtr* en consecuencia. Para obtener un ejemplo de cómo una aplicación puede recuperar datos de una máscara de SQLUINTEGER que incluya, vea "ejemplo de código".  
  
 Un controlador debe devolver un valor para cada tipo de información que se define en las tablas siguientes. Si un tipo de información no se aplica al controlador o el origen de datos, el controlador devuelve uno de los valores enumerados en la tabla siguiente.  

|Tipo de información|Value|
|-|-|
|Cadena de caracteres ("Y" o "N")|"N"|
|Cadena de caracteres (no es "Y" o "N")|cadena vacía.|
|SQLUSMALLINT|0|
|Máscara de SQLUINTEGER que incluya o valor binario SQLUINTEGER que incluya|0L|
  
 Por ejemplo, si un origen de datos no admite procedimientos, **SQLGetInfo** devuelve los valores que se muestran en la tabla siguiente para los valores de *InfoType* relacionados con los procedimientos.  

|InfoType|Value|
|-|-|
|SQL_PROCEDURES|"N"|
|SQL_ACCESSIBLE_PROCEDURES|"N"|
|SQL_MAX_PROCEDURE_NAME_LEN|0|
|SQL_PROCEDURE_TERM|cadena vacía.|
  
 **SQLGetInfo** devuelve SQLSTATE HY096 (valor de argumento no válido) para los valores de *InfoType* que se encuentran en el intervalo de tipos de información reservados para su uso por ODBC pero no definidos por la versión de ODBC que admite el controlador. Para determinar qué versión de ODBC cumple con el controlador, una aplicación llama a **SQLGetInfo** con el tipo de información SQL_DRIVER_ODBC_VER. **SQLGetInfo** devuelve SQLSTATE HYC00 (característica opcional no implementada) para los valores de *InfoType* que se encuentran en el intervalo de tipos de información reservados para uso específico del controlador, pero no son compatibles con el controlador.  
  
 Todas las llamadas a **SQLGetInfo** requieren una conexión abierta, excepto cuando *InfoType* está SQL_ODBC_VER, que devuelve la versión del administrador de controladores.  
  
## <a name="information-types"></a>Tipos de información  

 En esta sección se enumeran los tipos de información admitidos por **SQLGetInfo**. Los tipos de información se agrupan por categorías y se enumeran alfabéticamente. También se enumeran los tipos de información que se agregaron o cambiaron de nombre para ODBC 3 *. x* .  
  
## <a name="driver-information"></a>Información del controlador  

 Los siguientes valores del argumento *InfoType* devuelven información sobre el controlador ODBC, como el número de instrucciones activas, el nombre del origen de datos y el nivel de cumplimiento de los estándares de interfaz:  

:::row:::
    :::column:::
        SQL_ACTIVE_ENVIRONMENTS  
        SQL_ASYNC_DBC_FUNCTIONS  
        SQL_ASYNC_MODE  
        SQL_ASYNC_NOTIFICATION  
        SQL_BATCH_ROW_COUNT  
        SQL_BATCH_SUPPORT  
        SQL_DATA_SOURCE_NAME  
        SQL_DRIVER_AWARE_POOLING_SUPPORTED  
        SQL_DRIVER_HDBC  
        SQL_DRIVER_HDESC  
        SQL_DRIVER_HENV  
        SQL_DRIVER_HLIB  
        SQL_DRIVER_HSTMT  
        SQL_DRIVER_NAME  
        SQL_DRIVER_ODBC_VER  
        SQL_DRIVER_VER  
        SQL_DYNAMIC_CURSOR_ATTRIBUTES1  
        SQL_DYNAMIC_CURSOR_ATTRIBUTES2  
        SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1  
    :::column-end:::
    :::column:::
        SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2  
        SQL_FILE_USAGE  
        SQL_GETDATA_EXTENSIONS  
        SQL_INFO_SCHEMA_VIEWS  
        SQL_KEYSET_CURSOR_ATTRIBUTES1  
        SQL_KEYSET_CURSOR_ATTRIBUTES2  
        SQL_MAX_ASYNC_CONCURRENT_STATEMENTS  
        SQL_MAX_CONCURRENT_ACTIVITIES  
        SQL_MAX_DRIVER_CONNECTIONS  
        SQL_ODBC_INTERFACE_CONFORMANCE  
        SQL_ODBC_STANDARD_CLI_CONFORMANCE  
        SQL_ODBC_VER  
        SQL_PARAM_ARRAY_ROW_COUNTS  
        SQL_PARAM_ARRAY_SELECTS  
        SQL_ROW_UPDATES  
        SQL_SEARCH_PATTERN_ESCAPE  
        SQL_SERVER_NAME  
        SQL_STATIC_CURSOR_ATTRIBUTES1  
        SQL_STATIC_CURSOR_ATTRIBUTES2  
    :::column-end:::
:::row-end:::

> [!NOTE]  
> Al implementar **SQLGetInfo**, un controlador puede mejorar el rendimiento al minimizar el número de veces que la información se envía o solicita desde el servidor.  
  
## <a name="dbms-product-information"></a>Información del producto DBMS  

 Los siguientes valores del argumento *InfoType* devuelven información sobre el producto DBMS, como el nombre y la versión de DBMS:  

:::row:::
    :::column:::
        SQL_DATABASE_NAME  
        SQL_DBMS_NAME  
    :::column-end:::
    :::column:::
        SQL_DBMS_VER  
    :::column-end:::
:::row-end:::

## <a name="data-source-information"></a>Información del origen de datos  

 Los siguientes valores del argumento *InfoType* devuelven información sobre el origen de datos, como las características de los cursores y las capacidades de las transacciones:  

:::row:::
    :::column:::
        SQL_ACCESSIBLE_PROCEDURES  
        SQL_ACCESSIBLE_TABLES  
        SQL_BOOKMARK_PERSISTENCE  
        SQL_CATALOG_TERM  
        SQL_COLLATION_SEQ  
        SQL_CONCAT_NULL_BEHAVIOR  
        SQL_CURSOR_COMMIT_BEHAVIOR  
        SQL_CURSOR_ROLLBACK_BEHAVIOR  
        SQL_CURSOR_SENSITIVITY  
        SQL_DATA_SOURCE_READ_ONLY  
        SQL_DEFAULT_TXN_ISOLATION  
        SQL_DESCRIBE_PARAMETER  
    :::column-end:::
    :::column:::
        SQL_MULT_RESULT_SETS  
        SQL_MULTIPLE_ACTIVE_TXN  
        SQL_NEED_LONG_DATA_LEN  
        SQL_NULL_COLLATION  
        SQL_PROCEDURE_TERM  
        SQL_SCHEMA_TERM  
        SQL_SCROLL_OPTIONS  
        SQL_TABLE_TERM  
        SQL_TXN_CAPABLE  
        SQL_TXN_ISOLATION_OPTION  
        SQL_USER_NAME  
    :::column-end:::
:::row-end:::

## <a name="supported-sql"></a>SQL compatible  

 Los siguientes valores del argumento *InfoType* devuelven información acerca de las instrucciones SQL que admite el origen de datos. La sintaxis SQL de cada una de las características descritas por estos tipos de información es la sintaxis de SQL-92. Estos tipos de información no describen exhaustivamente toda la gramática de SQL-92. En su lugar, describen las partes de la gramática para las que los orígenes de datos suelen ofrecer distintos niveles de compatibilidad. En concreto, se describen la mayoría de las instrucciones de DDL en SQL-92.  
  
 Las aplicaciones deben determinar el nivel general de gramática admitida a partir del tipo de información de SQL_SQL_CONFORMANCE y usar los otros tipos de información para determinar las variaciones del nivel de cumplimiento de los estándares indicado.  

:::row:::
    :::column:::
        SQL_AGGREGATE_FUNCTIONS  
        SQL_ALTER_DOMAIN  
        SQL_ALTER_SCHEMA  
        SQL_ALTER_TABLE  
        SQL_ANSI_SQL_DATETIME_LITERALS  
        SQL_CATALOG_LOCATION  
        SQL_CATALOG_NAME  
        SQL_CATALOG_NAME_SEPARATOR  
        SQL_CATALOG_USAGE  
        SQL_COLUMN_ALIAS  
        SQL_CORRELATION_NAME  
        SQL_CREATE_ASSERTION  
        SQL_CREATE_CHARACTER_SET  
        SQL_CREATE_COLLATION  
        SQL_CREATE_DOMAIN  
        SQL_CREATE_SCHEMA  
        SQL_CREATE_TABLE  
        SQL_CREATE_TRANSLATION  
        SQL_DDL_INDEX  
        SQL_DROP_ASSERTION  
        SQL_DROP_CHARACTER_SET  
        SQL_DROP_COLLATION  
        SQL_DROP_DOMAIN  
        SQL_DROP_SCHEMA  
    :::column-end:::
    :::column:::
        SQL_DROP_TABLE  
        SQL_DROP_TRANSLATION  
        SQL_DROP_VIEW  
        SQL_EXPRESSIONS_IN_ORDERBY  
        SQL_GROUP_BY  
        SQL_IDENTIFIER_CASE  
        SQL_IDENTIFIER_QUOTE_CHAR  
        SQL_INDEX_KEYWORDS  
        SQL_INSERT_STATEMENT  
        SQL_INTEGRITY  
        SQL_KEYWORDS  
        SQL_LIKE_ESCAPE_CLAUSE  
        SQL_NON_NULLABLE_COLUMNS  
        SQL_OJ_CAPABILITIES  
        SQL_ORDER_BY_COLUMNS_IN_SELECT  
        SQL_OUTER_JOINS  
        SQL_PROCEDURES  
        SQL_QUOTED_IDENTIFIER_CASE  
        SQL_SCHEMA_USAGE  
        SQL_SPECIAL_CHARACTERS  
        SQL_SQL_CONFORMANCE  
        SQL_SUBQUERIES  
        SQL_UNION  
    :::column-end:::
:::row-end:::

## <a name="sql-limits"></a>Límites de SQL  

 Los siguientes valores del argumento *InfoType* devuelven información sobre los límites aplicados a identificadores y cláusulas en instrucciones SQL, como las longitudes máximas de los identificadores y el número máximo de columnas de una lista de selección. El controlador o el origen de datos pueden imponer limitaciones.  

:::row:::
    :::column:::
        SQL_MAX_BINARY_LITERAL_LEN  
        SQL_MAX_CATALOG_NAME_LEN  
        SQL_MAX_CHAR_LITERAL_LEN  
        SQL_MAX_COLUMN_NAME_LEN  
        SQL_MAX_COLUMNS_IN_GROUP_BY  
        SQL_MAX_COLUMNS_IN_INDEX  
        SQL_MAX_COLUMNS_IN_ORDER_BY  
        SQL_MAX_COLUMNS_IN_SELECT  
        SQL_MAX_COLUMNS_IN_TABLE  
        SQL_MAX_CURSOR_NAME_LEN  
    :::column-end:::
    :::column:::
        SQL_MAX_IDENTIFIER_LEN  
        SQL_MAX_INDEX_SIZE  
        SQL_MAX_PROCEDURE_NAME_LEN  
        SQL_MAX_ROW_SIZE  
        SQL_MAX_ROW_SIZE_INCLUDES_LONG  
        SQL_MAX_SCHEMA_NAME_LEN  
        SQL_MAX_STATEMENT_LEN  
        SQL_MAX_TABLE_NAME_LEN  
        SQL_MAX_TABLES_IN_SELECT  
        SQL_MAX_USER_NAME_LEN  
    :::column-end:::
:::row-end:::

## <a name="scalar-function-information"></a>Información de la función escalar  

 Los siguientes valores del argumento *InfoType* devuelven información sobre las funciones escalares admitidas por el origen de datos y el controlador. Para obtener más información sobre las funciones escalares, vea [Apéndice E: funciones escalares](../appendixes/appendix-e-scalar-functions.md).  

:::row:::
    :::column:::
        SQL_CONVERT_FUNCTIONS  
        SQL_NUMERIC_FUNCTIONS  
        SQL_STRING_FUNCTIONS  
        SQL_SYSTEM_FUNCTIONS  
    :::column-end:::
    :::column:::
        SQL_TIMEDATE_ADD_INTERVALS  
        SQL_TIMEDATE_DIFF_INTERVALS  
        SQL_TIMEDATE_FUNCTIONS  
    :::column-end:::
:::row-end:::

## <a name="conversion-information"></a>Información de conversión  

 Los siguientes valores del argumento *InfoType* devuelven una lista de los tipos de datos SQL a los que el origen de datos puede convertir el tipo de datos SQL especificado con la función escalar **Convert** :  

:::row:::
    :::column:::
        SQL_CONVERT_BIGINT  
        SQL_CONVERT_BINARY  
        SQL_CONVERT_BIT  
        SQL_CONVERT_CHAR  
        SQL_CONVERT_DATE  
        SQL_CONVERT_DECIMAL  
        SQL_CONVERT_DOUBLE  
        SQL_CONVERT_FLOAT  
        SQL_CONVERT_INTEGER  
        SQL_CONVERT_INTERVAL_DAY_TIME  
        SQL_CONVERT_INTERVAL_YEAR_MONTH  
    :::column-end:::
    :::column:::
        SQL_CONVERT_LONGVARBINARY  
        SQL_CONVERT_LONGVARCHAR  
        SQL_CONVERT_NUMERIC  
        SQL_CONVERT_REAL  
        SQL_CONVERT_SMALLINT  
        SQL_CONVERT_TIME  
        SQL_CONVERT_TIMESTAMP  
        SQL_CONVERT_TINYINT  
        SQL_CONVERT_VARBINARY  
        SQL_CONVERT_VARCHAR  
    :::column-end:::
:::row-end:::

## <a name="information-types-added-for-odbc-3x"></a>Tipos de información agregados para ODBC 3. x  

 Se han agregado los siguientes valores del argumento *InfoType* para ODBC 3. x:  

:::row:::
    :::column:::
        SQL_ACTIVE_ENVIRONMENTS  
        SQL_AGGREGATE_FUNCTIONS  
        SQL_ALTER_DOMAIN  
        SQL_ALTER_SCHEMA  
        SQL_ANSI_SQL_DATETIME_LITERALS  
        SQL_ASYNC_DBC_FUNCTIONS  
        SQL_ASYNC_MODE  
        SQL_ASYNC_NOTIFICATION  
        SQL_BATCH_ROW_COUNT  
        SQL_BATCH_SUPPORT  
        SQL_CATALOG_NAME  
        SQL_COLLATION_SEQ  
        SQL_CONVERT_INTERVAL_DAY_TIME  
        SQL_CONVERT_INTERVAL_YEAR_MONTH  
        SQL_CREATE_ASSERTION  
        SQL_CREATE_CHARACTER_SET  
        SQL_CREATE_COLLATION  
        SQL_CREATE_DOMAIN  
        SQL_CREATE_SCHEMA  
        SQL_CREATE_TABLE  
        SQL_CREATE_TRANSLATION  
        SQL_CURSOR_SENSITIVITY  
        SQL_DDL_INDEX  
        SQL_DESCRIBE_PARAMETER  
        SQL_DM_VER  
    :::column-end:::
    :::column:::
        SQL_DRIVER_AWARE_POOLING_SUPPORTED  
        SQL_DRIVER_HDESC  
        SQL_DROP_ASSERTION  
        SQL_DROP_CHARACTER_SET  
        SQL_DROP_COLLATION  
        SQL_DROP_DOMAIN  
        SQL_DROP_SCHEMA  
        SQL_DROP_TABLE  
        SQL_DROP_TRANSLATION  
        SQL_DROP_VIEW  
        SQL_DYNAMIC_CURSOR_ATTRIBUTES1  
        SQL_DYNAMIC_CURSOR_ATTRIBUTES2  
        SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1  
        SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2  
        SQL_INFO_SCHEMA_VIEWS  
        SQL_INSERT_STATEMENT  
        SQL_KEYSET_CURSOR_ATTRIBUTES1  
        SQL_KEYSET_CURSOR_ATTRIBUTES2  
        SQL_MAX_ASYNC_CONCURRENT_STATEMENTS  
        SQL_MAX_IDENTIFIER_LEN  
        SQL_PARAM_ARRAY_ROW_COUNTS  
        SQL_PARAM_ARRAY_SELECTS  
        SQL_STATIC_CURSOR_ATTRIBUTES1  
        SQL_STATIC_CURSOR_ATTRIBUTES2  
        SQL_XOPEN_CLI_YEAR  
    :::column-end:::
:::row-end:::

## <a name="information-types-renamed-for-odbc-3x"></a>Tipos de información cuyo nombre ha cambiado para ODBC 3. x  

 Se ha cambiado el nombre de los siguientes valores del argumento *InfoType* para ODBC 3. x.  

|Nombre anterior|Nuevo nombre|  
|-|-|  
|SQL_ACTIVE_CONNECTIONS|SQL_MAX_DRIVER_CONNECTIONS|
|SQL_ACTIVE_STATEMENTS|SQL_MAX_CONCURRENT_ACTIVITIES|
|SQL_MAX_OWNER_NAME_LEN|SQL_MAX_SCHEMA_NAME_LEN|
|SQL_MAX_QUALIFIER_NAME_LEN|SQL_MAX_CATALOG_NAME_LEN|
|SQL_ODBC_SQL_OPT_IEF|SQL_INTEGRITY|
|SQL_OWNER_TERM|SQL_SCHEMA_TERM|
|SQL_OWNER_USAGE|SQL_SCHEMA_USAGE|
|SQL_QUALIFIER_LOCATION|SQL_CATALOG_LOCATION|
|SQL_QUALIFIER_NAME_SEPARATOR|SQL_CATALOG_NAME_SEPARATOR|
|SQL_QUALIFIER_TERM|SQL_CATALOG_TERM|
|SQL_QUALIFIER_USAGE|SQL_CATALOG_USAGE|
  
## <a name="information-types-deprecated-in-odbc-3x"></a>Tipos de información desusados en ODBC 3. x  

 Los siguientes valores del argumento *InfoType* han quedado en desuso en ODBC 3. x. Los controladores ODBC 3. x deben seguir admitiendo estos tipos de información para mantener la compatibilidad con las aplicaciones ODBC 2. x. (Para obtener más información sobre estos tipos, vea [compatibilidad con SQLGetInfo](../appendixes/sqlgetinfo-support.md) en el Apéndice G: instrucciones de controlador para la compatibilidad con versiones anteriores).  

:::row:::
    :::column:::
        SQL_FETCH_DIRECTION  
        SQL_LOCK_TYPES  
        SQL_ODBC_API_CONFORMANCE  
        SQL_ODBC_SQL_CONFORMANCE  
    :::column-end:::
    :::column:::
        SQL_POS_OPERATIONS  
        SQL_POSITIONED_STATEMENTS  
        SQL_SCROLL_CONCURRENCY  
        SQL_STATIC_SENSITIVITY  
    :::column-end:::
:::row-end:::

## <a name="information-type-descriptions"></a>Descripción del tipo de información  

En la tabla siguiente se enumera alfabéticamente cada tipo de información, la versión de ODBC en la que se presentó y su descripción.  
  
|Tipo de información|Versión de ODBC|Descripción|
|-|-|-|
|SQL_ACCESSIBLE_PROCEDURES|1.0|Cadena de caracteres: "Y" si el usuario puede ejecutar todos los procedimientos devueltos por **SQLProcedures**; "N" si es posible que se devuelvan procedimientos que el usuario no pueda ejecutar.|
|SQL_ACCESSIBLE_TABLES|1.0|Una cadena de caracteres: "Y" si se garantiza que el usuario tiene privilegios **Select** para todas las tablas devueltas por **SQLTables**; "N" si es posible que se devuelvan tablas a las que el usuario no pueda tener acceso.|
|SQL_ACTIVE_ENVIRONMENTS|3.0|Un valor SQLUSMALLINT que especifica el número máximo de entornos activos que el controlador puede admitir. Si no hay ningún límite especificado o se desconoce el límite, este valor se establece en cero.|
|SQL_AGGREGATE_FUNCTIONS|3.0|Una máscara de SQLUINTEGER que incluya que enumera la compatibilidad para las funciones de agregación:<br/>SQL_AF_ALL<br/>SQL_AF_AVG<br/>SQL_AF_COUNT<br/>SQL_AF_DISTINCT<br/>SQL_AF_MAX<br/>SQL_AF_MIN<br/>SQL_AF_SUM<br/><br/>Un controlador compatible con el nivel de entrada SQL-92 siempre devolverá todas las opciones que se admiten.|
|SQL_ALTER_DOMAIN|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las cláusulas de la instrucción **ALTER Domain** , tal como se define en SQL-92, admitidas por el origen de datos. Un controlador compatible con el nivel completo de SQL-92 siempre devolverá todas las máscaras de bits. Un valor devuelto de "0" significa que no se admite la instrucción **ALTER Domain** .<br/><br/>El nivel de conformidad con SQL-92 o FIPS en el que se debe admitir esta característica se muestra entre paréntesis junto a cada máscara de bits.<br/><br/>Las siguientes máscaras de código se usan para determinar qué cláusulas se admiten:<br/>SQL_AD_ADD_DOMAIN_CONSTRAINT = se admite la adición de una restricción de dominio (nivel completo)<br/>SQL_AD_ADD_DOMAIN_DEFAULT = \<alter domain> \<set domain default clause> es compatible (nivel completo)<br/>SQL_AD_CONSTRAINT_NAME_DEFINITION = \<constraint name definition clause> es compatible con la restricción de dominio de nomenclatura (nivel intermedio)<br/>SQL_AD_DROP_DOMAIN_CONSTRAINT = \<drop domain constraint clause> es compatible (nivel completo)<br/>SQL_AD_DROP_DOMAIN_DEFAULT = \<alter domain> \<drop domain default clause> es compatible (nivel completo)<br/><br/>Los bits siguientes especifican el admitido \<constraint attributes> si \<add domain constraint> se admite (el bit SQL_AD_ADD_DOMAIN_CONSTRAINT está establecido):<br/>SQL_AD_ADD_CONSTRAINT_DEFERRABLE (nivel completo)<br/>SQL_AD_ADD_CONSTRAINT_NON_DEFERRABLE (nivel completo)<br/>SQL_AD_ADD_CONSTRAINT_INITIALLY_DEFERRED (nivel completo)<br/>SQL_AD_ADD_CONSTRAINT_INITIALLY_IMMEDIATE (nivel completo)|
|SQL_ALTER_TABLE|2.0|Máscara de SQLUINTEGER que incluya que enumera las cláusulas de la instrucción **ALTER TABLE** que admite el origen de datos.<br/><br/>El nivel de conformidad con SQL-92 o FIPS en el que se debe admitir esta característica se muestra entre paréntesis junto a cada máscara de bits.<br/><br/>Las siguientes máscaras de código se usan para determinar qué cláusulas se admiten:<br/>\<add column>Se admite la cláusula SQL_AT_ADD_COLUMN_COLLATION =, con el recurso para especificar la intercalación de columnas (nivel completo) (ODBC 3,0)<br/>\<add column>Se admite la cláusula SQL_AT_ADD_COLUMN_DEFAULT =, con la posibilidad de especificar valores predeterminados de columna (nivel de transición de FIPS) (ODBC 3,0)<br/>SQL_AT_ADD_COLUMN_SINGLE = \<add column> es compatible (nivel de transición FIPS) (ODBC 3,0)<br/>\<add column>Se admite la cláusula SQL_AT_ADD_CONSTRAINT =, con el recurso para especificar restricciones de columna (nivel de transición FIPS) (ODBC 3,0)<br/>\<add table constraint>Se admite la cláusula SQL_AT_ADD_TABLE_CONSTRAINT = (nivel de transición de FIPS) (ODBC 3,0)<br/>SQL_AT_CONSTRAINT_NAME_DEFINITION = \<constraint name definition> es compatible con las restricciones de columna y tabla de nomenclatura (nivel intermedio) (ODBC 3,0)<br/>SQL_AT_DROP_COLUMN_CASCADE = \<drop column> Cascade es compatible (nivel de transición FIPS) (ODBC 3,0)<br/>SQL_AT_DROP_COLUMN_DEFAULT = \<alter column> \<drop column default clause> es compatible (nivel intermedio) (ODBC 3,0)<br/>\<drop column>Se admite SQL_AT_DROP_COLUMN_RESTRICT = Restrict (nivel de transición de FIPS) (ODBC 3,0)<br/>SQL_AT_DROP_TABLE_CONSTRAINT_CASCADE (ODBC 3,0)<br/>\<drop column>Se admite SQL_AT_DROP_TABLE_CONSTRAINT_RESTRICT = Restrict (nivel de transición de FIPS) (ODBC 3,0)<br/>SQL_AT_SET_COLUMN_DEFAULT = \<alter column> \<set column default clause> es compatible (nivel intermedio) (ODBC 3,0)<br/><br/>Los bits siguientes especifican la compatibilidad \<constraint attributes> si se admite la especificación de restricciones de columna o tabla (se establece el bit SQL_AT_ADD_CONSTRAINT):<br/>SQL_AT_CONSTRAINT_INITIALLY_DEFERRED (nivel completo) (ODBC 3,0)<br/>SQL_AT_CONSTRAINT_INITIALLY_IMMEDIATE (nivel completo) (ODBC 3,0)<br/>SQL_AT_CONSTRAINT_DEFERRABLE (nivel completo) (ODBC 3,0)<br/>SQL_AT_CONSTRAINT_NON_DEFERRABLE (nivel completo) (ODBC 3,0)|
|SQL_ASYNC_DBC_FUNCTIONS|3.8|Un valor SQLUINTEGER que incluya que indica si el controlador puede ejecutar funciones de forma asincrónica en el identificador de conexión.<br/><br/>SQL_ASYNC_DBC_CAPABLE = el controlador puede ejecutar funciones de conexión de forma asincrónica.<br/>SQL_ASYNC_DBC_NOT_CAPABLE = el controlador no puede ejecutar funciones de conexión de forma asincrónica.|
|SQL_ASYNC_MODE|3.0|Un valor SQLUINTEGER que incluya que indica el nivel de compatibilidad asincrónica en el controlador:<br/><br/>SQL_AM_CONNECTION = se admite la ejecución asincrónica en el nivel de conexión. Todos los identificadores de instrucciones asociados a un identificador de conexión determinado están en modo asincrónico o todos están en modo sincrónico. Un identificador de instrucción en una conexión no puede estar en modo asincrónico mientras que otro identificador de instrucción en la misma conexión está en modo sincrónico y viceversa.<br/>SQL_AM_STATEMENT = se admite la ejecución asincrónica en el nivel de instrucción. Algunos identificadores de instrucciones asociados a un identificador de conexión pueden estar en modo asincrónico, mientras que otros identificadores de instrucciones en la misma conexión están en modo sincrónico.<br/>SQL_AM_NONE = no se admite el modo asincrónico.|
|SQL_ASYNC_NOTIFICATION|3.8|Un valor SQLUINTEGER que incluya que indica si el controlador admite la notificación asincrónica:<br/><br/>SQL_ASYNC_NOTIFICATION_CAPABLE = la notificación de ejecución asincrónica es compatible con el controlador.<br/>SQL_ASYNC_NOTIFICATION_NOT_CAPABLE = la notificación de ejecución asincrónica no es compatible con el controlador.<br/><br/>Existen dos categorías de operaciones asincrónicas de ODBC: operaciones asincrónicas de nivel de conexión y operaciones asincrónicas de nivel de instrucción.  Si un controlador devuelve SQL_ASYNC_NOTIFICATION_CAPABLE, debe admitir la notificación de todas las API que puede ejecutar de forma asincrónica.|
|SQL_BATCH_ROW_COUNT|3.0|Máscara de SQLUINTEGER que incluya que enumera el comportamiento del controlador con respecto a la disponibilidad de los recuentos de filas. Las siguientes máscaras de código se usan junto con el tipo de información:<br/><br/>SQL_BRC_ROLLED_UP = los recuentos de filas de instrucciones INSERT, DELETE o UPDATE consecutivas se acumulan en uno. Si no se establece este bit, los recuentos de filas estarán disponibles para cada instrucción.<br/>SQL_BRC_PROCEDURES = los recuentos de filas, si los hay, están disponibles cuando se ejecuta un lote en un procedimiento almacenado. Si los recuentos de filas están disponibles, pueden acumularse o estar disponibles de forma individual, dependiendo del bit de SQL_BRC_ROLLED_UP.<br/>SQL_BRC_EXPLICIT = los recuentos de filas, si los hay, están disponibles cuando se ejecuta un lote directamente mediante una llamada a **SQLExecute** o **SQLExecDirect**. Si los recuentos de filas están disponibles, pueden acumularse o estar disponibles de forma individual, dependiendo del bit de SQL_BRC_ROLLED_UP.|
|SQL_BATCH_SUPPORT|3.0|Una máscara de SQLUINTEGER que incluya que enumera la compatibilidad del controlador con los lotes. Las siguientes máscaras de código se usan para determinar el nivel admitido:<br/><br/>SQL_BS_SELECT_EXPLICIT = el controlador admite lotes explícitos que pueden tener instrucciones de generación de conjuntos de resultados.<br/>SQL_BS_ROW_COUNT_EXPLICIT = el controlador admite lotes explícitos que pueden tener instrucciones de generación de recuento de filas.<br/>SQL_BS_SELECT_PROC = el controlador admite procedimientos explícitos que pueden tener instrucciones de generación de conjuntos de resultados.<br/>SQL_BS_ROW_COUNT_PROC = el controlador admite procedimientos explícitos que pueden tener instrucciones de generación de recuento de filas.|
|SQL_BOOKMARK_PERSISTENCE|2.0|Una máscara de SQLUINTEGER que incluya que enumera las operaciones a través de las que los marcadores se conservan. Las siguientes máscaras de código se usan junto con la marca para determinar a qué opciones se conservan los marcadores:<br/><br/>SQL_BP_CLOSE = los marcadores son válidos después de que una aplicación llame a **SQLFreeStmt** con la opción SQL_CLOSE, o **SQLCloseCursor** para cerrar el cursor asociado a una instrucción.<br/>SQL_BP_DELETE = el marcador de una fila es válido después de que se haya eliminado la fila.<br/>SQL_BP_DROP = los marcadores son válidos después de que una aplicación llame a **SQLFreeHandle** con un *HandleType* de SQL_HANDLE_STMT para quitar una instrucción.<br/>SQL_BP_TRANSACTION = los marcadores son válidos después de que una aplicación se confirma o revierte una transacción.<br/>SQL_BP_UPDATE = el marcador de una fila es válido después de actualizar cualquier columna de esa fila, incluidas las columnas de clave.<br/>SQL_BP_OTHER_HSTMT = se puede usar un marcador asociado a una instrucción con otra instrucción. A menos que se especifique SQL_BP_CLOSE o SQL_BP_DROP, el cursor de la primera instrucción debe estar abierto.|
|SQL_CATALOG_LOCATION|2.0|Un valor SQLUSMALLINT que indica la posición del catálogo en un nombre de tabla completo:<br/><br/>SQL_CL_START<br/>SQL_CL_END<br/>Por ejemplo, un controlador xBase devuelve SQL_CL_START porque el nombre del directorio (catálogo) está al principio del nombre de la tabla, como en \EMPDATA\EMP. DBF. Un controlador de servidor de ORACLE devuelve SQL_CL_END porque el catálogo está al final del nombre de la tabla, como en ADMIN.EMP@EMPDATA .<br/><br/>Un controlador compatible con el nivel completo de SQL-92 siempre devolverá SQL_CL_START. Se devuelve el valor 0 si el origen de datos no admite los catálogos. Para determinar si se admiten los catálogos, una aplicación llama a **SQLGetInfo** con el tipo de información SQL_CATALOG_NAME.<br/><br/>Se ha cambiado el nombre de *InfoType* a ODBC 3,0 de ODBC 2,0 *InfoType* SQL_QUALIFIER_LOCATION.|
|SQL_CATALOG_NAME|3.0|Una cadena de caracteres: "Y" si el servidor admite nombres de catálogo o "N" si no es así.<br/><br/>Un controlador compatible con el nivel completo de SQL-92 siempre devolverá "Y".|
|SQL_CATALOG_NAME_SEPARATOR|1.0|Una cadena de caracteres: el carácter o los caracteres que el origen de datos define como separador entre un nombre de catálogo y el elemento de nombre completo que sigue o lo precede.<br/><br/>Se devuelve una cadena vacía si el origen de datos no admite los catálogos. Para determinar si se admiten los catálogos, una aplicación llama a **SQLGetInfo** con el tipo de información SQL_CATALOG_NAME. Un controlador compatible con el nivel completo de SQL-92 siempre devolverá ".".<br/><br/>Se ha cambiado el nombre de *InfoType* a ODBC 3,0 de ODBC 2,0 *InfoType* SQL_QUALIFIER_NAME_SEPARATOR.|
|SQL_CATALOG_TERM|1.0|Cadena de caracteres con el nombre del proveedor del origen de datos para un catálogo; por ejemplo, "base de datos" o "directorio". Esta cadena puede estar en mayúsculas, minúsculas o mezcladas.<br/><br/>Se devuelve una cadena vacía si el origen de datos no admite los catálogos. Para determinar si se admiten los catálogos, una aplicación llama a **SQLGetInfo** con el tipo de información SQL_CATALOG_NAME. Un controlador compatible con el nivel completo de SQL-92 siempre devolverá "Catálogo".<br/><br/>Se ha cambiado el nombre de *InfoType* a ODBC 3,0 de ODBC 2,0 *InfoType* SQL_QUALIFIER_TERM.|
|SQL_CATALOG_USAGE|2.0|Una máscara de SQLUINTEGER que incluya que enumera las instrucciones en las que se pueden usar los catálogos.<br/><br/>Las siguientes máscaras de código se usan para determinar dónde se pueden usar los catálogos:<br/>SQL_CU_DML_STATEMENTS = los catálogos se admiten en todas las instrucciones de lenguaje de manipulación de datos: **Select**, **Insert**, **Update**, **Delete** y, si se admite, **Seleccione para** las instrucciones Update y posicionada Update y DELETE.<br/>SQL_CU_PROCEDURE_INVOCATION = los catálogos se admiten en la instrucción de invocación de procedimiento ODBC.<br/>SQL_CU_TABLE_DEFINITION = los catálogos se admiten en todas las instrucciones de definición de tabla: **CREATE TABLE**, **Create View**, **ALTER TABLE**, **DROP TABLE** y **Drop View**.<br/>SQL_CU_INDEX_DEFINITION = los catálogos se admiten en todas las instrucciones de definición de índice: **Create index** y **Drop index**.<br/>SQL_CU_PRIVILEGE_DEFINITION = los catálogos se admiten en todas las instrucciones de definición de privilegios: **Grant** y **REVOKE**.<br/><br/>Se devuelve el valor 0 si el origen de datos no admite los catálogos. Para determinar si se admiten los catálogos, una aplicación llama a **SQLGetInfo** con el tipo de información SQL_CATALOG_NAME. Un controlador compatible con el nivel completo de SQL-92 siempre devolverá una máscara de bits con todos estos bits establecidos.<br/><br/>Se ha cambiado el nombre de *InfoType* a ODBC 3,0 de ODBC 2,0 *InfoType* SQL_QUALIFIER_USAGE.|
|SQL_COLLATION_SEQ|3.0|Nombre de la secuencia de intercalación. Se trata de una cadena de caracteres que indica el nombre de la intercalación predeterminada del juego de caracteres predeterminado para este servidor (por ejemplo, ' ISO 8859-1 ' o EBCDIC). Si no se conoce, se devolverá una cadena vacía. Un controlador compatible con el nivel completo de SQL-92 siempre devolverá una cadena no vacía.|
|SQL_COLUMN_ALIAS|2.0|Cadena de caracteres: "Y" si el origen de datos admite alias de columna; de lo contrario, "N".<br/><br/>Un alias de columna es un nombre alternativo que se puede especificar para una columna en la lista de selección mediante el uso de una cláusula AS. Un controlador compatible con el nivel de entrada SQL-92 siempre devolverá "Y".|
|SQL_CONCAT_NULL_BEHAVIOR|1.0|Un valor SQLUSMALLINT que indica cómo el origen de datos controla la concatenación de columnas de tipo de datos de caracteres con valores NULL con columnas de tipo de datos de caracteres que no son NULL:<br/>SQL_CB_NULL = el resultado es un valor NULL.<br/>SQL_CB_NON_NULL = el resultado es la concatenación de columnas o columnas con valores que no son NULL.<br/><br/>Un controlador compatible con el nivel de entrada SQL-92 siempre devolverá SQL_CB_NULL.|
|SQL_CONVERT_BIGINT<br/>SQL_CONVERT_BINARY<br/>SQL_CONVERT_BIT<br/>SQL_CONVERT_CHAR<br/>SQL_CONVERT_GUID<br/>SQL_CONVERT_DATE<br/>SQL_CONVERT_DECIMAL<br/>SQL_CONVERT_DOUBLE<br/>SQL_CONVERT_FLOAT<br/>SQL_CONVERT_INTEGER<br/>SQL_CONVERT_INTERVAL_YEAR_MONTH<br/>SQL_CONVERT_INTERVAL_DAY_TIME<br/>SQL_CONVERT_LONGVARBINARY<br/>SQL_CONVERT_LONGVARCHAR<br/>SQL_CONVERT_NUMERIC<br/>SQL_CONVERT_REAL<br/>SQL_CONVERT_SMALLINT<br/>SQL_CONVERT_TIME<br/>SQL_CONVERT_TIMESTAMP<br/>SQL_CONVERT_TINYINT<br/>SQL_CONVERT_VARBINARY<br/>SQL_CONVERT_VARCHAR|1.0|Máscara de SQLUINTEGER que incluya. La máscara de máscara indica las conversiones admitidas por el origen de datos con la función escalar **Convert** para los datos del tipo denominado en *InfoType*. Si la máscara de la máscara es igual a cero, el origen de datos no admite conversiones de datos del tipo con nombre, incluida la conversión al mismo tipo de datos.<br/><br/>Por ejemplo, para determinar si un origen de datos admite la conversión de datos de SQL_INTEGER en el tipo de datos SQL_BIGINT, una aplicación llama a **SQLGetInfo** con el *InfoType* de SQL_CONVERT_INTEGER. La aplicación realiza una operación **and** con la máscara de la información y el SQL_CVT_BIGINT devueltos. Si el valor resultante es distinto de cero, se admite la conversión.<br/><br/>Las siguientes máscaras de código se usan para determinar qué conversiones se admiten:<br/>SQL_CVT_BIGINT (ODBC 1,0)<br/>SQL_CVT_BINARY (ODBC 1,0)<br/>SQL_CVT_BIT (ODBC 1,0)<br/>SQL_CVT_GUID (ODBC 3,5)<br/>SQL_CVT_CHAR (ODBC 1,0)<br/>SQL_CVT_DATE (ODBC 1,0)<br/>SQL_CVT_DECIMAL (ODBC 1,0)<br/>SQL_CVT_DOUBLE (ODBC 1,0)<br/>SQL_CVT_FLOAT (ODBC 1,0)<br/>SQL_CVT_INTEGER (ODBC 1,0)<br/>SQL_CVT_INTERVAL_YEAR_MONTH (ODBC 3,0)<br/>SQL_CVT_INTERVAL_DAY_TIME (ODBC 3,0)<br/>SQL_CVT_LONGVARBINARY (ODBC 1,0)<br/>SQL_CVT_LONGVARCHAR (ODBC 1,0)<br/>SQL_CVT_NUMERIC (ODBC 1,0)<br/>SQL_CVT_REAL (ODBC 1,0)<br/>SQL_CVT_SMALLINT (ODBC 1,0)<br/>SQL_CVT_TIME (ODBC 1,0)<br/>SQL_CVT_TIMESTAMP (ODBC 1,0)<br/>SQL_CVT_TINYINT (ODBC 1,0)<br/>SQL_CVT_VARBINARY (ODBC 1,0)<br/>SQL_CVT_VARCHAR (ODBC 1,0)|
|SQL_CONVERT_FUNCTIONS|1.0|Una máscara de SQLUINTEGER que incluya que enumera las funciones de conversión escalar admitidas por el controlador y el origen de datos asociado.<br/><br/>La siguiente máscara de máscara se usa para determinar qué funciones de conversión se admiten:<br/>SQL_FN_CVT_CASTSQL_FN_CVT_CONVERT|
|SQL_CORRELATION_NAME|1.0|Un valor SQLUSMALLINT que indica si se admiten los nombres de correlación de tabla:<br/>SQL_CN_NONE = no se admiten nombres de correlación.<br/>SQL_CN_DIFFERENT = se admiten nombres de correlación, pero deben ser diferentes de los nombres de las tablas que representan.<br/>SQL_CN_ANY = se admiten nombres de correlación y pueden ser cualquier nombre válido definido por el usuario.<br/><br/>Un controlador compatible con el nivel de entrada SQL-92 siempre devolverá SQL_CN_ANY.|
|SQL_CREATE_ASSERTION|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las cláusulas de la instrucción **Create Assertion** , tal como se define en SQL-92, admitidas por el origen de datos.<br/><br/>Las siguientes máscaras de código se usan para determinar qué cláusulas se admiten:<br/>SQL_CA_CREATE_ASSERTION<br/><br/>Los bits siguientes especifican el atributo de restricción admitido si se admite la capacidad de especificar explícitamente los atributos de restricción (vea los tipos de información SQL_ALTER_TABLE y SQL_CREATE_TABLE):<br/>SQL_CA_CONSTRAINT_INITIALLY_DEFERRED<br/>SQL_CA_CONSTRAINT_INITIALLY_IMMEDIATE<br/>SQL_CA_CONSTRAINT_DEFERRABLE<br/>SQL_CA_CONSTRAINT_NON_DEFERRABLE<br/><br/>Un controlador compatible con el nivel completo de SQL-92 siempre devolverá todas las opciones que se admiten. Un valor devuelto de "0" significa que no se admite la instrucción **Create Assertion** .|
|SQL_CREATE_CHARACTER_SET|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las cláusulas de la instrucción **Create Character Set** , tal como se define en SQL-92, admitidas por el origen de datos.<br/><br/>Las siguientes máscaras de código se usan para determinar qué cláusulas se admiten:<br/>SQL_CCS_CREATE_CHARACTER_SET<br/>SQL_CCS_COLLATE_CLAUSE<br/>SQL_CCS_LIMITED_COLLATION<br/><br/>Un controlador compatible con el nivel completo de SQL-92 siempre devolverá todas las opciones que se admiten. Un valor devuelto de "0" significa que no se admite la instrucción **Create Character Set** .|
|SQL_CREATE_COLLATION|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las cláusulas de la instrucción **Create collation** , tal como se define en SQL-92, admitidas por el origen de datos.<br/><br/>La siguiente máscara de máscara se usa para determinar qué cláusulas se admiten:<br/>SQL_CCOL_CREATE_COLLATION<br/><br/>Un controlador compatible con el nivel completo de SQL-92 siempre devolverá esta opción como compatible. Un valor devuelto de "0" significa que no se admite la instrucción **Create collation** .|
|SQL_CREATE_DOMAIN|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las cláusulas de la instrucción **Create Domain** , tal como se define en SQL-92, admitidas por el origen de datos.<br/><br/>Las siguientes máscaras de código se usan para determinar qué cláusulas se admiten:<br/>SQL_CDO_CREATE_DOMAIN = se admite la instrucción CREATE DOMAIN (nivel intermedio).<br/>SQL_CDO_CONSTRAINT_NAME_DEFINITION = \<constraint name definition> es compatible con las restricciones de dominio de nomenclatura (nivel intermedio).<br/><br/>Los bits siguientes especifican la capacidad de crear restricciones de columna:<br/>SQL_CDO_DEFAULT = se admite la especificación de restricciones de dominio (nivel intermedio)<br/>SQL_CDO_CONSTRAINT = se admite la especificación de valores predeterminados de dominio (nivel intermedio)<br/>SQL_CDO_COLLATION = se admite la especificación de intercalación de dominio (nivel completo)<br/><br/>Los bits siguientes especifican los atributos de restricción admitidos si se admite la especificación de restricciones de dominio (se establece SQL_CDO_DEFAULT):<br/>SQL_CDO_CONSTRAINT_INITIALLY_DEFERRED (nivel completo)<br/>SQL_CDO_CONSTRAINT_INITIALLY_IMMEDIATE (nivel completo)<br/>SQL_CDO_CONSTRAINT_DEFERRABLE (nivel completo)<br/>SQL_CDO_CONSTRAINT_NON_DEFERRABLE (nivel completo)<br/><br/>Un valor devuelto de "0" significa que no se admite la instrucción **Create Domain** .|
|SQL_CREATE_SCHEMA|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las cláusulas en la instrucción **Create Schema** , tal como se define en SQL-92, admitidas por el origen de datos.<br/><br/>Las siguientes máscaras de código se usan para determinar qué cláusulas se admiten:<br/>SQL_CS_CREATE_SCHEMA<br/>SQL_CS_AUTHORIZATION<br/>SQL_CS_DEFAULT_CHARACTER_SET<br/><br/>Un controlador compatible con el nivel intermedio de SQL-92 siempre devolverá las opciones SQL_CS_CREATE_SCHEMA y SQL_CS_AUTHORIZATION como se admiten. También se deben admitir en el nivel de entrada SQL-92, pero no necesariamente como instrucciones SQL. Un controlador compatible con el nivel completo de SQL-92 siempre devolverá todas las opciones que se admiten.|
|SQL_CREATE_TABLE|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las cláusulas de la instrucción **CREATE TABLE** , tal como se define en SQL-92, admitidas por el origen de datos.<br/><br/>El nivel de conformidad con SQL-92 o FIPS en el que se debe admitir esta característica se muestra entre paréntesis junto a cada máscara de bits.<br/><br/>Las siguientes máscaras de código se usan para determinar qué cláusulas se admiten:<br/>SQL_CT_CREATE_TABLE = se admite la instrucción CREATE TABLE. (Nivel de entrada)<br/>SQL_CT_TABLE_CONSTRAINT = se admite la especificación de restricciones de tabla (nivel de transición de FIPS)<br/>SQL_CT_CONSTRAINT_NAME_DEFINITION = la \<constraint name definition> cláusula se admite para asignar nombres a las restricciones de columna y de tabla (nivel intermedio)<br/><br/>Los bits siguientes especifican la capacidad de crear tablas temporales:<br/>SQL_CT_COMMIT_PRESERVE = las filas eliminadas se conservan en la confirmación. (Nivel completo)<br/>SQL_CT_COMMIT_DELETE = las filas eliminadas se eliminan al confirmar. (Nivel completo)<br/>SQL_CT_GLOBAL_TEMPORARY = se pueden crear tablas temporales globales. (Nivel completo)<br/>SQL_CT_LOCAL_TEMPORARY = se pueden crear tablas temporales locales. (Nivel completo)<br/><br/>Los bits siguientes especifican la capacidad de crear restricciones de columna:<br/>SQL_CT_COLUMN_CONSTRAINT = se admite la especificación de restricciones de columna (nivel de transición de FIPS)<br/>SQL_CT_COLUMN_DEFAULT = se admite la especificación de valores predeterminados de columna (nivel de transición de FIPS)<br/>SQL_CT_COLUMN_COLLATION = se admite la especificación de la intercalación de columnas (nivel completo)<br/><br/>Los bits siguientes especifican los atributos de restricción admitidos si se admite la especificación de restricciones de columna o tabla:<br/>SQL_CT_CONSTRAINT_INITIALLY_DEFERRED (nivel completo)<br/>SQL_CT_CONSTRAINT_INITIALLY_IMMEDIATE (nivel completo)<br/>SQL_CT_CONSTRAINT_DEFERRABLE (nivel completo)<br/>SQL_CT_CONSTRAINT_NON_DEFERRABLE (nivel completo)|
|SQL_CREATE_TRANSLATION|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las cláusulas de la instrucción **Create Translation** , tal como se define en SQL-92, admitidas por el origen de datos.<br/><br/>La siguiente máscara de máscara se usa para determinar qué cláusulas se admiten:<br/>SQL_CTR_CREATE_TRANSLATION<br/><br/>Un controlador compatible con el nivel completo de SQL-92 siempre devolverá estas opciones como se admiten. Un valor devuelto de "0" significa que no se admite la instrucción **Create Translation** .|
|SQL_CREATE_VIEW|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las cláusulas de la instrucción **Create View** , tal como se define en SQL-92, admitidas por el origen de datos.<br/><br/>Las siguientes máscaras de código se usan para determinar qué cláusulas se admiten:<br/>SQL_CV_CREATE_VIEW<br/>SQL_CV_CHECK_OPTION<br/>SQL_CV_CASCADED<br/>SQL_CV_LOCAL<br/><br/>Un valor devuelto de "0" significa que no se admite la instrucción **Create View** .<br/><br/>Un controlador compatible con el nivel de entrada SQL-92 siempre devolverá las opciones SQL_CV_CREATE_VIEW y SQL_CV_CHECK_OPTION como se admiten.<br/><br/>Un controlador compatible con el nivel completo de SQL-92 siempre devolverá todas las opciones que se admiten.|
|SQL_CURSOR_COMMIT_BEHAVIOR|1.0|Un valor SQLUSMALLINT que indica cómo una operación de **confirmación** afecta a los cursores y a las instrucciones preparadas en el origen de datos (el comportamiento del origen de datos cuando se confirma una transacción).<br/><br/>El valor de este atributo reflejará el estado actual del siguiente valor: SQL_COPT_SS_PRESERVE_CURSORS.<br/>SQL_CB_DELETE = cerrar cursores y eliminar instrucciones preparadas. Para volver a utilizar el cursor, la aplicación debe volver a preparar y ejecutar la instrucción.<br/>SQL_CB_CLOSE = cerrar cursores. En el caso de las instrucciones preparadas, la aplicación puede llamar a **SQLExecute** en la instrucción sin llamar de nuevo a **SQLPrepare** . El valor predeterminado para el controlador ODBC de SQL es SQL_CB_CLOSE. Esto significa que el controlador ODBC de SQL cerrará los cursores al confirmar una transacción.<br/>SQL_CB_PRESERVE = conservar los cursores en la misma posición que antes de la operación de **confirmación** . La aplicación puede seguir recuperando datos o puede cerrar el cursor y volver a ejecutar la instrucción sin revelarla.|
|SQL_CURSOR_ROLLBACK_BEHAVIOR|1.0|Un valor SQLUSMALLINT que indica cómo una operación de **reversión** afecta a los cursores y a las instrucciones preparadas en el origen de datos:<br/>SQL_CB_DELETE = cerrar cursores y eliminar instrucciones preparadas. Para volver a utilizar el cursor, la aplicación debe volver a preparar y ejecutar la instrucción.<br/>SQL_CB_CLOSE = cerrar cursores. En el caso de las instrucciones preparadas, la aplicación puede llamar a **SQLExecute** en la instrucción sin llamar de nuevo a **SQLPrepare** .<br/>SQL_CB_PRESERVE = conservar los cursores en la misma posición que antes de la operación de **reversión** . La aplicación puede seguir recuperando datos o puede cerrar el cursor y volver a ejecutar la instrucción sin revelarla.|
|SQL_CURSOR_SENSITIVITY|3.0|Un valor SQLUINTEGER que incluya que indica la compatibilidad con la sensibilidad del cursor:<br/>SQL_INSENSITIVE = todos los cursores del identificador de instrucción muestran el conjunto de resultados sin reflejar los cambios que se realizaron en él mediante ningún otro cursor dentro de la misma transacción.<br/>SQL_UNSPECIFIED = no se especifica si los cursores del controlador de la instrucción hacen visibles los cambios realizados en un conjunto de resultados por otro cursor dentro de la misma transacción. Los cursores del identificador de instrucción pueden hacer visibles ninguno, algunos o todos esos cambios.<br/>SQL_SENSITIVE = los cursores son sensibles a los cambios realizados por otros cursores dentro de la misma transacción.<br/><br/>Un controlador compatible con el nivel de entrada SQL-92 siempre devolverá la opción SQL_UNSPECIFIED tal como se admite.<br/><br/>Un controlador compatible con el nivel completo de SQL-92 siempre devolverá la opción SQL_INSENSITIVE como admitida.|
|SQL_DATA_SOURCE_NAME|1.0|Cadena de caracteres con el nombre del origen de datos que se usó durante la conexión. Si la aplicación llamó a **SQLConnect**, este es el valor del argumento *szDSN* . Si la aplicación llamó a **SQLDriverConnect** o **SQLBrowseConnect**, es el valor de la palabra clave DSN en la cadena de conexión que se pasa al controlador. Si la cadena de conexión no contiene la palabra clave **DSN** (como cuando contiene la palabra clave **driver** ), se trata de una cadena vacía.|
|SQL_DATA_SOURCE_READ_ONLY|1.0|Una cadena de caracteres. "Y" si el origen de datos se establece en modo de solo lectura, "N" si no es así.<br/><br/>Esta característica solo pertenece al propio origen de datos; no es una característica del controlador que permite el acceso al origen de datos. Un controlador que sea de lectura/escritura puede utilizarse con un origen de datos que sea de solo lectura. Si un controlador es de solo lectura, todos sus orígenes de datos deben ser de solo lectura y deben devolver SQL_DATA_SOURCE_READ_ONLY.|
|SQL_DATABASE_NAME|1.0|Cadena de caracteres con el nombre de la base de datos actual en uso, si el origen de datos define un objeto con nombre denominado "Database".<br/><br/>En ODBC 3. x, el valor devuelto para este *InfoType* también se puede devolver llamando a **SQLGetConnectAttr** con un argumento de *atributo* de SQL_ATTR_CURRENT_CATALOG.|
|SQL_DATETIME_LITERALS|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera los literales de fecha y hora de SQL-92 que admite el origen de datos. Tenga en cuenta que estos son los literales de fecha y hora que se enumeran en la especificación SQL-92 y que son independientes de las cláusulas de escape literal de fecha y hora definidas por ODBC. Para obtener más información sobre las cláusulas de escape de literales DateTime de ODBC, vea [literales de fecha, hora y marca de tiempo](../develop-app/date-time-and-timestamp-literals.md).<br/><br/> Un controlador compatible con el nivel de transición FIPS siempre devolverá el valor "1" en la máscara de bits de los bits de la lista siguiente. Un valor de "0" significa que no se admiten los literales de fecha y hora de SQL-92.<br/><br/>Las siguientes máscaras de código se usan para determinar los literales admitidos:<br/>SQL_DL_SQL92_DATE<br/>SQL_DL_SQL92_TIME<br/>SQL_DL_SQL92_TIMESTAMP<br/>SQL_DL_SQL92_INTERVAL_YEAR<br/>SQL_DL_SQL92_INTERVAL_MONTH<br/>SQL_DL_SQL92_INTERVAL_DAY<br/>SQL_DL_SQL92_INTERVAL_HOUR<br/>SQL_DL_SQL92_INTERVAL_MINUTE<br/>SQL_DL_SQL92_INTERVAL_SECOND<br/>SQL_DL_SQL92_INTERVAL_YEAR_TO_MONTH<br/>SQL_DL_SQL92_INTERVAL_DAY_TO_HOUR<br/>SQL_DL_SQL92_INTERVAL_DAY_TO_MINUTE<br/>SQL_DL_SQL92_INTERVAL_DAY_TO_SECOND<br/>SQL_DL_SQL92_INTERVAL_HOUR_TO_MINUTE<br/>SQL_DL_SQL92_INTERVAL_HOUR_TO_SECOND<br/>SQL_DL_SQL92_INTERVAL_MINUTE_TO_SECOND|
|SQL_DBMS_NAME|1.0|Cadena de caracteres con el nombre del producto DBMS al que tiene acceso el controlador.|
|SQL_DBMS_VER|1.0|Cadena de caracteres que indica la versión del producto DBMS a la que tiene acceso el controlador. La versión tiene el formato # #. # #. # # #, donde los dos primeros dígitos son la versión principal, los dos dígitos siguientes son la versión secundaria y los últimos cuatro dígitos son la versión de lanzamiento. El controlador debe representar la versión del producto DBMS de esta forma, pero también puede anexar la versión específica del producto DBMS. Por ejemplo, "04.01.0000 RDB 4,1".|
|SQL_DDL_INDEX|3.0|Un valor SQLUINTEGER que incluya que indica compatibilidad con la creación y la eliminación de índices:<br/>SQL_DI_CREATE_INDEX<br/>SQL_DI_DROP_INDEX|
|SQL_DEFAULT_TXN_ISOLATION|1.0|Un valor SQLUINTEGER que incluya que indica el nivel de aislamiento de transacción predeterminado admitido por el controlador o el origen de datos, o bien cero si el origen de datos no admite transacciones. Los siguientes términos se usan para definir los niveles de aislamiento de transacción:<br/>**Lectura sucia** La transacción 1 cambia una fila. La transacción 2 lee la fila modificada antes de que la transacción 1 confirme el cambio. Si la transacción 1 revierte el cambio, la transacción 2 habrá leído una fila que se considera que nunca existía.<br/>**Lectura no repetible** La transacción 1 Lee una fila. La transacción 2 actualiza o elimina esa fila y confirma este cambio. Si la transacción 1 intenta volver a leer la fila, recibirá valores de fila diferentes o detectará que se ha eliminado la fila.<br/>**Fantasma** La transacción 1 Lee un conjunto de filas que cumplen algunos criterios de búsqueda. La transacción 2 genera una o varias filas (a través de inserciones o actualizaciones) que coinciden con los criterios de búsqueda. Si la transacción 1 vuelve a ejecutar la instrucción que lee las filas, recibe un conjunto de filas diferente.<br/><br/>Si el origen de datos admite transacciones, el controlador devuelve una de las siguientes máscaras de código:<br/>SQL_TXN_READ_UNCOMMITTED = es posible que haya lecturas desfasadas, lecturas no repetibles y fantasmas.<br/>SQL_TXN_READ_COMMITTED = no se pueden realizar lecturas desfasadas. Son posibles las lecturas no repetibles y las fantasmas.<br/>SQL_TXN_REPEATABLE_READ = no se pueden realizar lecturas desfasadas ni lecturas no repetibles. Los fantasmas son posibles.<br/>SQL_TXN_SERIALIZABLE = las transacciones son serializables. Las transacciones serializables no permiten lecturas desfasadas, lecturas no repetibles o fantasmas.|
|SQL_DESCRIBE_PARAMETER|3.0|Una cadena de caracteres: "Y" si se pueden describir parámetros; "N", si no es así.<br/><br/>Un controlador compatible con el nivel completo de SQL-92 devolverá normalmente "Y" porque admitirá la instrucción de **entrada de Descripción** . Como esto no especifica directamente la compatibilidad con SQL subyacente, no obstante, es posible que no se admita la descripción de los parámetros, incluso en un controlador compatible con el nivel completo de SQL-92.|
|SQL_DM_VER|3.0|Cadena de caracteres con la versión del administrador de controladores. La versión tiene el formato # #. # #. # # # #. # # # #, donde:<br/>El primer conjunto de dos dígitos es la versión de ODBC principal, como se indica en la SQL_SPEC_MAJOR constante.<br/>El segundo conjunto de dos dígitos es la versión de ODBC secundaria, según lo especificado por la constante SQL_SPEC_MINOR.<br/>El tercer conjunto de cuatro dígitos es el número de compilación principal del administrador de controladores.<br/>El último conjunto de cuatro dígitos es el número de compilación secundaria del administrador de controladores.<br/>La versión del administrador de controladores de Windows 7 es 03,80. La versión del administrador de controladores de Windows 8 es 03,81.|
|SQL_DRIVER_AWARE_POOLING_SUPPORTED|3.8|Valor de SQLUINTEGER que incluya que indica si el controlador admite la agrupación compatible con controladores. (Para obtener más información, consulte [agrupación de conexiones compatible con controladores](../develop-app/driver-aware-connection-pooling.md).<br/><br/>SQL_DRIVER_AWARE_POOLING_CAPABLE indica que el controlador puede admitir el mecanismo de agrupación compatible con el controlador.<br/>SQL_DRIVER_AWARE_POOLING_NOT_CAPABLE indica que el controlador no admite el mecanismo de agrupación compatible con controladores.<br/><br/>Un controlador no necesita implementar SQL_DRIVER_AWARE_POOLING_SUPPORTED y el administrador de controladores no respetará el valor devuelto del controlador.|
|SQL_DRIVER_HDBCSQL_DRIVER_HENV|1.0|Un valor SQLULEN, el identificador de la conexión o el identificador de entorno del controlador, determinado por el argumento *InfoType*.<br/><br/>Estos tipos de información se implementan solo en el administrador de controladores.|
|SQL_DRIVER_HDESC|3.0|Un valor SQLULEN, el identificador de descriptor del controlador determinado por el identificador del descriptor del administrador de controladores, que se debe pasar en la entrada de \* *InfoValuePtr* desde la aplicación. En este caso, *InfoValuePtr* es un argumento de entrada y de salida. El identificador de descriptor de entrada pasado en \* *InfoValuePtr* debe haberse asignado explícita o implícitamente en *ConnectionHandle*.<br/><br/>La aplicación debe realizar una copia del identificador de descriptor del administrador de controladores antes de llamar a **SQLGetInfo** con este tipo de información, para asegurarse de que el identificador no se sobrescribe en la salida.<br/><br/>Este tipo de información lo implementa solo el administrador de controladores.|
|SQL_DRIVER_HLIB|2.0|Un valor SQLULEN, el *HINST* de la biblioteca de carga que se devuelve al administrador de controladores cuando cargó la dll del controlador en un sistema operativo Microsoft Windows, o su equivalente en otro sistema operativo. El identificador solo es válido para el identificador de conexión especificado en la llamada a **SQLGetInfo**.<br/><br/>Este tipo de información lo implementa solo el administrador de controladores.|
|SQL_DRIVER_HSTMT|1.0|Un valor de SQLULEN, el identificador de instrucción del controlador determinado por el identificador de instrucción del administrador de controladores, que se debe pasar en la entrada de \* *InfoValuePtr* desde la aplicación. En este caso, *InfoValuePtr* es una entrada y un argumento de salida. El identificador de instrucción de entrada pasado en \* *InfoValuePtr* debe haberse asignado en el argumento *ConnectionHandle*.<br/><br/>La aplicación debe realizar una copia del identificador de instrucción del administrador de controladores antes de llamar a **SQLGetInfo** con este tipo de información, para asegurarse de que el identificador no se sobrescribe en la salida.<br/><br/>Este tipo de información lo implementa solo el administrador de controladores.|
|SQL_DRIVER_NAME|1.0|Cadena de caracteres con el nombre de archivo del controlador utilizado para tener acceso al origen de datos.|
|SQL_DRIVER_ODBC_VER|2.0|Cadena de caracteres con la versión de ODBC que admite el controlador. La versión tiene el formato # #. # #, donde los dos primeros dígitos son la versión principal y los dos dígitos siguientes son la versión secundaria. SQL_SPEC_MAJOR y SQL_SPEC_MINOR definen los números de versión principal y secundaria. En el caso de la versión de ODBC que se describe en este manual, estos son 3 y 0, y el controlador debe devolver "03,00".<br/><br/>El administrador de controladores ODBC no modificará el valor devuelto de SQLGetInfo (SQL_DRIVER_ODBC_VER) para mantener la compatibilidad con versiones anteriores de las aplicaciones existentes. El controlador especifica qué valor se devolverá. Sin embargo, un controlador que admite la extensibilidad de tipos de datos de C debe devolver 3,8 (o superior) cuando una aplicación llama a **SQLSetEnvAttr** para establecer SQL_ATTR_ODBC_VERSION en 3,8. Para obtener más información, vea el tema sobre [tipos de datos C en ODBC](../develop-app/c-data-types-in-odbc.md).|
|SQL_DRIVER_VER|1.0|Una cadena de caracteres con la versión del controlador y, opcionalmente, una descripción del controlador. Como mínimo, la versión tiene el formato # #. # #. # # # #, donde los dos primeros dígitos son la versión principal, los dos dígitos siguientes son la versión secundaria y los últimos cuatro dígitos son la versión de lanzamiento.|
|SQL_DROP_ASSERTION|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las cláusulas de la instrucción **Drop Assertion** , tal como se define en SQL-92, admitidas por el origen de datos.<br/><br/>La siguiente máscara de máscara se usa para determinar qué cláusulas se admiten:<br/>SQL_DA_DROP_ASSERTION<br/><br/>Un controlador compatible con el nivel completo de SQL-92 siempre devolverá esta opción como compatible.|
|SQL_DROP_CHARACTER_SET|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las cláusulas de la instrucción **Drop Character Set** , tal como se define en SQL-92, admitidas por el origen de datos.<br/><br/>La siguiente máscara de máscara se usa para determinar qué cláusulas se admiten:<br/>SQL_DCS_DROP_CHARACTER_SET<br/><br/>Un controlador compatible con el nivel completo de SQL-92 siempre devolverá esta opción como compatible.|
|SQL_DROP_COLLATION|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las cláusulas de la instrucción **Drop collation** , tal como se define en SQL-92, admitidas por el origen de datos.<br/><br/>La siguiente máscara de máscara se usa para determinar qué cláusulas se admiten:<br/>SQL_DC_DROP_COLLATION<br/><br/>Un controlador compatible con el nivel completo de SQL-92 siempre devolverá esta opción como compatible.|
|SQL_DROP_DOMAIN|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las cláusulas de la instrucción **Drop Domain** , tal como se define en SQL-92, admitidas por el origen de datos.<br/><br/>Las siguientes máscaras de código se usan para determinar qué cláusulas se admiten:<br/>SQL_DD_DROP_DOMAIN<br/>SQL_DD_CASCADE<br/>SQL_DD_RESTRICT<br/><br/>Un controlador compatible con el nivel intermedio de SQL-92 siempre devolverá todas las opciones que se admiten.|
|SQL_DROP_SCHEMA|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las cláusulas de la instrucción **Drop Schema** , tal como se define en SQL-92, admitidas por el origen de datos.<br/><br/>Las siguientes máscaras de código se usan para determinar qué cláusulas se admiten:<br/>SQL_DS_DROP_SCHEMA<br/>SQL_DS_CASCADE<br/>SQL_DS_RESTRICT<br/><br/>Un controlador compatible con el nivel intermedio de SQL-92 siempre devolverá todas las opciones que se admiten.|
|SQL_DROP_TABLE|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las cláusulas de la instrucción **DROP TABLE** , tal como se define en SQL-92, admitidas por el origen de datos.<br/><br/>Las siguientes máscaras de código se usan para determinar qué cláusulas se admiten:<br/>SQL_DT_DROP_TABLE<br/>SQL_DT_CASCADE<br/>SQL_DT_RESTRICT<br/><br/>Un controlador compatible con el nivel de transición FIPS siempre devolverá todas las opciones que se admiten.|
|SQL_DROP_TRANSLATION|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las cláusulas de la instrucción **Drop Translation** , tal como se define en SQL-92, admitidas por el origen de datos.<br/><br/>La siguiente máscara de máscara se usa para determinar qué cláusulas se admiten:<br/>SQL_DTR_DROP_TRANSLATION<br/><br/>Un controlador compatible con el nivel completo de SQL-92 siempre devolverá esta opción como compatible.|
|SQL_DROP_VIEW|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las cláusulas de la instrucción **Drop View** , tal como se define en SQL-92, admitidas por el origen de datos.<br/><br/>Las siguientes máscaras de código se usan para determinar qué cláusulas se admiten:<br/>SQL_DV_DROP_VIEW<br/>SQL_DV_CASCADE<br/>SQL_DV_RESTRICT<br/><br/>Un controlador compatible con el nivel de transición FIPS siempre devolverá todas las opciones que se admiten.|
|SQL_DYNAMIC_CURSOR_ATTRIBUTES1|3.0|Máscara de SQLUINTEGER que incluya que describe los atributos de un cursor dinámico que son compatibles con el controlador. Esta máscara de subred contiene el primer subconjunto de atributos; para el segundo subconjunto, consulte SQL_DYNAMIC_CURSOR_ATTRIBUTES2.<br/><br/>Las siguientes máscaras de código se usan para determinar los atributos que se admiten:<br/>SQL_CA1_NEXT = se admite un argumento *FetchOrientation* de SQL_FETCH_NEXT en una llamada a **SQLFetchScroll** cuando el cursor es un cursor dinámico.<br/>SQL_CA1_ABSOLUTE = *FetchOrientation* argumentos de SQL_FETCH_FIRST, SQL_FETCH_LAST y SQL_FETCH_ABSOLUTE se admiten en una llamada a **SQLFetchScroll** cuando el cursor es un cursor dinámico. (El conjunto de filas que se capturará es independiente de la posición actual del cursor).<br/>SQL_CA1_RELATIVE = *FetchOrientation* argumentos de SQL_FETCH_PRIOR y SQL_FETCH_RELATIVE se admiten en una llamada a **SQLFetchScroll** cuando el cursor es un cursor dinámico. (El conjunto de filas que se capturará depende de la posición actual del cursor. Tenga en cuenta que esto está separado de SQL_FETCH_NEXT porque en un cursor de solo avance solo se admite SQL_FETCH_NEXT).<br/>SQL_CA1_BOOKMARK = se admite un argumento *FetchOrientation* de SQL_FETCH_BOOKMARK en una llamada a **SQLFetchScroll** cuando el cursor es un cursor dinámico.<br/>SQL_CA1_LOCK_EXCLUSIVE = se admite un argumento *LockType* de SQL_LOCK_EXCLUSIVE en una llamada a **SQLSetPos** cuando el cursor es un cursor dinámico.<br/>SQL_CA1_LOCK_NO_CHANGE = se admite un argumento *LockType* de SQL_LOCK_NO_CHANGE en una llamada a **SQLSetPos** cuando el cursor es un cursor dinámico.<br/>SQL_CA1_LOCK_UNLOCK = se admite un argumento *LockType* de SQL_LOCK_UNLOCK en una llamada a **SQLSetPos** cuando el cursor es un cursor dinámico.<br/>SQL_CA1_POS_POSITION = se admite un argumento de *operación* de SQL_POSITION en una llamada a **SQLSetPos** cuando el cursor es un cursor dinámico.<br/>SQL_CA1_POS_UPDATE = se admite un argumento de *operación* de SQL_UPDATE en una llamada a **SQLSetPos** cuando el cursor es un cursor dinámico.<br/>SQL_CA1_POS_DELETE = se admite un argumento de *operación* de SQL_DELETE en una llamada a **SQLSetPos** cuando el cursor es un cursor dinámico.<br/>SQL_CA1_POS_REFRESH = se admite un argumento de *operación* de SQL_REFRESH en una llamada a **SQLSetPos** cuando el cursor es un cursor dinámico.<br/>SQL_CA1_POSITIONED_UPDATE = una actualización en la que se admite CURRENT de la instrucción SQL cuando el cursor es un cursor dinámico. (Un controlador compatible con el nivel de entrada SQL-92 siempre devolverá esta opción como compatible).<br/>SQL_CA1_POSITIONED_DELETE = una instrucción DELETE donde CURRENT OF SQL se admite cuando el cursor es un cursor dinámico. (Un controlador compatible con el nivel de entrada SQL-92 siempre devolverá esta opción como compatible).<br/>SQL_CA1_SELECT_FOR_UPDATE = se admite una instrucción SELECT FOR UPDATE de SQL cuando el cursor es un cursor dinámico. (Un controlador compatible con el nivel de entrada SQL-92 siempre devolverá esta opción como compatible).<br/>SQL_CA1_BULK_ADD = se admite un argumento de *operación* de SQL_ADD en una llamada a **SQLBulkOperations** cuando el cursor es un cursor dinámico.<br/>SQL_CA1_BULK_UPDATE_BY_BOOKMARK = se admite un argumento de *operación* de SQL_UPDATE_BY_BOOKMARK en una llamada a **SQLBulkOperations** cuando el cursor es un cursor dinámico.<br/>SQL_CA1_BULK_DELETE_BY_BOOKMARK = se admite un argumento de *operación* de SQL_DELETE_BY_BOOKMARK en una llamada a **SQLBulkOperations** cuando el cursor es un cursor dinámico.<br/>SQL_CA1_BULK_FETCH_BY_BOOKMARK = se admite un argumento de *operación* de SQL_FETCH_BY_BOOKMARK en una llamada a **SQLBulkOperations** cuando el cursor es un cursor dinámico.<br/><br/>Normalmente, un controlador compatible con el nivel intermedio de SQL-92 devolverá las opciones SQL_CA1_NEXT, SQL_CA1_ABSOLUTE y SQL_CA1_RELATIVE tal como se admiten, ya que admite cursores desplazables a través de la instrucción SQL FETCH incrustada. Como esto no determina directamente la compatibilidad con SQL subyacente, no obstante, es posible que no se admitan los cursores desplazables, incluso para un controlador compatible con el nivel intermedio de SQL-92.|
|SQL_DYNAMIC_CURSOR_ATTRIBUTES2|3.0|Máscara de SQLUINTEGER que incluya que describe los atributos de un cursor dinámico que son compatibles con el controlador. Esta máscara de subred contiene el segundo subconjunto de atributos; para el primer subconjunto, consulte SQL_DYNAMIC_CURSOR_ATTRIBUTES1.<br/><br/>Las siguientes máscaras de código se usan para determinar los atributos que se admiten:<br/>SQL_CA2_READ_ONLY_CONCURRENCY = un cursor dinámico de solo lectura, en el que no se permite ninguna actualización, se admite. (El atributo de instrucción SQL_ATTR_CONCURRENCY se puede SQL_CONCUR_READ_ONLY para un cursor dinámico).<br/>SQL_CA2_LOCK_CONCURRENCY = un cursor dinámico que utiliza el nivel más bajo de bloqueo suficiente para asegurarse de que se admite la actualización de la fila. (El atributo de instrucción SQL_ATTR_CONCURRENCY se puede SQL_CONCUR_LOCK para un cursor dinámico). Estos bloqueos deben ser coherentes con el nivel de aislamiento de transacción establecido por el atributo de conexión SQL_ATTR_TXN_ISOLATION.<br/>SQL_CA2_OPT_ROWVER_CONCURRENCY = se admite un cursor dinámico que usa el control de simultaneidad optimista que compara las versiones de fila. (El atributo de instrucción SQL_ATTR_CONCURRENCY se puede SQL_CONCUR_ROWVER para un cursor dinámico).<br/>SQL_CA2_OPT_VALUES_CONCURRENCY = se admite un cursor dinámico que utiliza el control de simultaneidad optimista que compara valores. (El atributo de instrucción SQL_ATTR_CONCURRENCY se puede SQL_CONCUR_VALUES para un cursor dinámico).<br/>SQL_CA2_SENSITIVITY_ADDITIONS = las filas agregadas son visibles para un cursor dinámico; el cursor puede desplazarse hasta esas filas. (Las filas que se agregan al cursor dependen del controlador).<br/>SQL_CA2_SENSITIVITY_DELETIONS = las filas eliminadas ya no están disponibles para un cursor dinámico y no dejan un "agujero" en el conjunto de resultados; una vez que el cursor dinámico se desplaza de una fila eliminada, no puede volver a esa fila.<br/>SQL_CA2_SENSITIVITY_UPDATES = las actualizaciones de las filas son visibles para un cursor dinámico; Si el cursor dinámico se desplaza desde y vuelve a una fila actualizada, los datos devueltos por el cursor son los datos actualizados, no los datos originales.<br/>SQL_CA2_MAX_ROWS_SELECT = el atributo de instrucción SQL_ATTR_MAX_ROWS afecta a las instrucciones **Select** cuando el cursor es un cursor dinámico.<br/>SQL_CA2_MAX_ROWS_INSERT = el atributo de instrucción SQL_ATTR_MAX_ROWS afecta a las instrucciones **Insert** cuando el cursor es un cursor dinámico.<br/>SQL_CA2_MAX_ROWS_DELETE = el atributo de instrucción SQL_ATTR_MAX_ROWS afecta a las instrucciones **Delete** cuando el cursor es un cursor dinámico.<br/>SQL_CA2_MAX_ROWS_UPDATE = el atributo de instrucción SQL_ATTR_MAX_ROWS afecta a las instrucciones **Update** cuando el cursor es un cursor dinámico.<br/>SQL_CA2_MAX_ROWS_CATALOG = el atributo de instrucción SQL_ATTR_MAX_ROWS afecta a los conjuntos de resultados del **Catálogo** cuando el cursor es un cursor dinámico.<br/>SQL_CA2_MAX_ROWS_AFFECTS_ALL = el atributo de instrucción SQL_ATTR_MAX_ROWS afecta a las instrucciones **Select**, **Insert**, **Delete** y **Update** , y a los conjuntos de resultados del **Catálogo** , cuando el cursor es un cursor dinámico.<br/>SQL_CA2_CRC_EXACT = el recuento exacto de filas está disponible en el campo diagnóstico de SQL_DIAG_CURSOR_ROW_COUNT cuando el cursor es un cursor dinámico.<br/>SQL_CA2_CRC_APPROXIMATE = un recuento de filas aproximado está disponible en el campo diagnóstico de SQL_DIAG_CURSOR_ROW_COUNT cuando el cursor es un cursor dinámico.<br/>SQL_CA2_SIMULATE_NON_UNIQUE = el controlador no garantiza que las instrucciones UPDATE o DELETE de posición simuladas solo afecten a una fila cuando el cursor sea un cursor dinámico; es responsabilidad de la aplicación garantizar esto. (Si una instrucción afecta a más de una fila, **SQLExecute** o **SQLExecDirect** devuelve SQLSTATE 01001 [conflicto de operación de cursor]). Para establecer este comportamiento, la aplicación llama a **SQLSetStmtAttr** con el atributo SQL_ATTR_SIMULATE_CURSOR establecido en SQL_SC_NON_UNIQUE.<br/>SQL_CA2_SIMULATE_TRY_UNIQUE = el controlador intenta garantizar que las instrucciones UPDATE o DELETE posicionadas solo afecten a una fila cuando el cursor sea un cursor dinámico. El controlador siempre ejecuta estas instrucciones, incluso si pueden afectar a más de una fila, por ejemplo, cuando no hay ninguna clave única. (Si una instrucción afecta a más de una fila, **SQLExecute** o **SQLExecDirect** devuelve SQLSTATE 01001 [conflicto de operación de cursor]). Para establecer este comportamiento, la aplicación llama a **SQLSetStmtAttr** con el atributo SQL_ATTR_SIMULATE_CURSOR establecido en SQL_SC_TRY_UNIQUE.<br/>SQL_CA2_SIMULATE_UNIQUE = el controlador garantiza que las instrucciones UPDATE o DELETE posicionadas solo afecten a una fila cuando el cursor sea un cursor dinámico. Si el controlador no puede garantizar esto para una instrucción determinada, **SQLExecDirect** o **SQLPrepare** devuelven SQLSTATE 01001 (conflicto de la operación de cursor). Para establecer este comportamiento, la aplicación llama a **SQLSetStmtAttr** con el atributo SQL_ATTR_SIMULATE_CURSOR establecido en SQL_SC_UNIQUE.|
|SQL_EXPRESSIONS_IN_ORDERBY|1.0|Cadena de caracteres: "Y" si el origen de datos admite expresiones en la lista **order by** ; Si no es así, "N".|
|SQL_FILE_USAGE|2.0|Un valor SQLUSMALLINT que indica cómo un controlador de un solo nivel trata directamente los archivos de un origen de datos:<br/>SQL_FILE_NOT_SUPPORTED = el controlador no es un controlador de un solo nivel. Por ejemplo, un controlador de ORACLE es un controlador de dos niveles.<br/>SQL_FILE_TABLE = un controlador de un solo nivel trata los archivos de un origen de datos como tablas. Por ejemplo, un controlador xBase trata cada archivo xBase como una tabla.<br/>SQL_FILE_CATALOG = un controlador de un solo nivel trata los archivos de un origen de datos como un catálogo. Por ejemplo, un controlador de Microsoft Access trata cada archivo de Microsoft Access como una base de datos completa.<br/><br/>Una aplicación podría usar esta información para determinar cómo seleccionarán los usuarios los datos. Por ejemplo, los usuarios de xBase suelen pensar en los datos tal como se almacenan en los archivos, mientras que los usuarios de ORACLE y Microsoft Access suelen pensar en los datos tal como se almacenan en tablas.<br/><br/>Cuando un usuario selecciona un origen de datos xBase, la aplicación podría mostrar el cuadro de diálogo Abrir común de **archivos** de Windows. Cuando el usuario selecciona un origen de datos de Microsoft Access u ORACLE, la aplicación podría mostrar un cuadro de diálogo **seleccionar tabla** personalizada.|
|SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1|3.0|Máscara de bits SQLUINTEGER que incluya que describe los atributos de un cursor de solo avance que son compatibles con el controlador. Esta máscara de subred contiene el primer subconjunto de atributos; para el segundo subconjunto, consulte SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2.<br/><br/>Las siguientes máscaras de código se usan para determinar los atributos que se admiten:<br/>SQL_CA1_NEXT<br/>SQL_CA1_LOCK_EXCLUSIVE<br/>SQL_CA1_LOCK_NO_CHANGE<br/>SQL_CA1_LOCK_UNLOCK<br/>SQL_CA1_POS_POSITION<br/>SQL_CA1_POS_UPDATE<br/>SQL_CA1_POS_DELETE<br/>SQL_CA1_POS_REFRESH<br/>SQL_CA1_POSITIONED_UPDATE<br/>SQL_CA1_POSITIONED_DELETE<br/>SQL_CA1_SELECT_FOR_UPDATE<br/>SQL_CA1_BULK_ADD<br/>SQL_CA1_BULK_UPDATE_BY_BOOKMARK<br/>SQL_CA1_BULK_DELETE_BY_BOOKMARK<br/>SQL_CA1_BULK_FETCH_BY_BOOKMARK<br/><br/>Para obtener descripciones de estas máscaras de bits, vea SQL_DYNAMIC_CURSOR_ATTRIBUTES1 (y sustituir "cursor de solo avance" por "cursor dinámico" en las descripciones).|
|SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2|3.0|Máscara de bits SQLUINTEGER que incluya que describe los atributos de un cursor de solo avance que son compatibles con el controlador. Esta máscara de subred contiene el segundo subconjunto de atributos; para el primer subconjunto, consulte SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1.<br/><br/>Las siguientes máscaras de código se usan para determinar los atributos que se admiten:<br/>SQL_CA2_READ_ONLY_CONCURRENCY<br/>SQL_CA2_LOCK_CONCURRENCY<br/>SQL_CA2_OPT_ROWVER_CONCURRENCY<br/>SQL_CA2_OPT_VALUES_CONCURRENCY<br/>SQL_CA2_SENSITIVITY_ADDITIONS<br/>SQL_CA2_SENSITIVITY_DELETIONS<br/>SQL_CA2_SENSITIVITY_UPDATES<br/>SQL_CA2_MAX_ROWS_SELECT<br/>SQL_CA2_MAX_ROWS_INSERT<br/>SQL_CA2_MAX_ROWS_DELETE<br/>SQL_CA2_MAX_ROWS_UPDATE<br/>SQL_CA2_MAX_ROWS_CATALOG<br/>SQL_CA2_MAX_ROWS_AFFECTS_ALL<br/>SQL_CA2_CRC_EXACT<br/>SQL_CA2_CRC_APPROXIMATE<br/>SQL_CA2_SIMULATE_NON_UNIQUE<br/>SQL_CA2_SIMULATE_TRY_UNIQUE<br/>SQL_CA2_SIMULATE_UNIQUE<br/><br/>Para obtener descripciones de estas máscaras de bits, vea SQL_DYNAMIC_CURSOR_ATTRIBUTES2 (y sustituir "cursor de solo avance" por "cursor dinámico" en las descripciones).|
|SQL_GETDATA_EXTENSIONS|2.0|Una máscara de SQLUINTEGER que incluya que enumera las extensiones de **SQLGetData**.<br/><br/>Las siguientes máscaras de código se usan junto con la marca para determinar las extensiones comunes que admite el controlador para **SQLGetData**:<br/>SQL_GD_ANY_COLUMN = **SQLGetData** se puede llamar a para cualquier columna sin enlazar, incluidas las anteriores a la última columna enlazada. Tenga en cuenta que se debe llamar a las columnas por orden de número de columna ascendente a menos que también se devuelva SQL_GD_ANY_ORDER.<br/>SQL_GD_ANY_ORDER = **SQLGetData** se puede llamar para las columnas sin enlazar en cualquier orden. Tenga en cuenta que solo se puede llamar a **SQLGetData** para las columnas posteriores a la última columna enlazada a menos que también se devuelva SQL_GD_ANY_COLUMN.<br/>Se puede llamar a SQL_GD_BLOCK = **SQLGetData** para una columna sin enlazar en cualquier fila de un bloque (donde el tamaño del conjunto de filas es mayor que 1) de datos después de colocarse en esa fila con **SQLSetPos**.<br/>SQL_GD_BOUND = **SQLGetData** se puede llamar a para las columnas enlazadas además de a las columnas sin enlazar. Un controlador no puede devolver este valor a menos que también devuelva SQL_GD_ANY_COLUMN.<br/>SQL_GD_OUTPUT_PARAMS = **SQLGetData** se puede llamar para devolver valores de parámetros de salida. Para obtener más información, vea el tema que trata sobre [recuperar parámetros de salida mediante SQLGetData](../develop-app/retrieving-output-parameters-using-sqlgetdata.md).<br/><br/>**SQLGetData** es necesario para devolver datos solo de las columnas no enlazadas que se producen después de la última columna enlazada, se llama en orden de número de columna creciente y no están en una fila de un bloque de filas.<br/><br/>Si un controlador admite marcadores (de longitud fija o de longitud variable), debe admitir la llamada a **SQLGetData** en la columna 0. Esta compatibilidad es necesaria independientemente de lo que el controlador devuelva para una llamada a **SQLGetInfo** con el SQL_GETDATA_EXTENSIONS *InfoType*.|
|SQL_GROUP_BY|2.0|Valor SQLUSMALLINT que especifica la relación entre las columnas de la cláusula **Group by** y las columnas no agregadas de la lista de selección:<br/>SQL_GB_COLLATE = se puede especificar una cláusula **COLLATE** al final de cada columna de agrupación. (ODBC 3,0)<br/>SQL_GB_NOT_SUPPORTED = no se admiten las cláusulas **Group by** . (ODBC 2,0)<br/>SQL_GB_GROUP_BY_EQUALS_SELECT = la cláusula **Group by** debe contener todas las columnas no agregadas de la lista de selección. No puede contener ninguna otra columna. Por ejemplo, **Seleccione Dept, Max (salario) de Employee Group by Dept**. (ODBC 2,0)<br/>SQL_GB_GROUP_BY_CONTAINS_SELECT = la cláusula **Group by** debe contener todas las columnas no agregadas de la lista de selección. Puede contener columnas que no están en la lista de selección. Por ejemplo, **Seleccione Dept, Max (salario) de Employee Group by Dept, Age**. (ODBC 2,0)<br/>SQL_GB_NO_RELATION = las columnas de la cláusula **Group by** y la lista de selección no están relacionadas. El significado de las columnas no agrupadas y no agregadas en la lista de selección depende del origen de datos. Por ejemplo, **Seleccione Dept, salario de Employee Group by Dept, Age**. (ODBC 2,0)<br/><br/>Un controlador compatible con el nivel de entrada SQL-92 siempre devolverá la opción SQL_GB_GROUP_BY_EQUALS_SELECT tal como se admite. Un controlador compatible con el nivel completo de SQL-92 siempre devolverá la opción SQL_GB_COLLATE como admitida. Si no se admite ninguna de las opciones, el origen de datos no admite la cláusula **Group by** .|
|SQL_IDENTIFIER_CASE|1.0|Un valor de SQLUSMALLINT como se indica a continuación:<br/>SQL_IC_UPPER = los identificadores de SQL no distinguen mayúsculas de minúsculas y se almacenan en mayúsculas en el catálogo del sistema.<br/>SQL_IC_LOWER = los identificadores de SQL no distinguen mayúsculas de minúsculas y se almacenan en minúsculas en el catálogo del sistema.<br/>SQL_IC_SENSITIVE = los identificadores de SQL distinguen mayúsculas de minúsculas y se almacenan en el catálogo del sistema.<br/>SQL_IC_MIXED = los identificadores de SQL no distinguen mayúsculas de minúsculas y se almacenan en el catálogo del sistema.<br/><br/>Dado que los identificadores en SQL-92 nunca distinguen mayúsculas de minúsculas, un controlador que se ajuste estrictamente a SQL-92 (cualquier nivel) nunca devolverá la opción SQL_IC_SENSITIVE como compatible.|
|SQL_IDENTIFIER_QUOTE_CHAR|1.0|Cadena de caracteres que se utiliza como delimitador inicial y final de un identificador entre comillas (delimitado) en las instrucciones SQL. (Los identificadores pasados como argumentos a funciones ODBC no tienen que estar entrecomillados). Si el origen de datos no admite identificadores entrecomillados, se devuelve un espacio en blanco.<br/><br/>Esta cadena de caracteres también se puede utilizar para entrecomillar los argumentos de la función de catálogo cuando el atributo de conexión SQL_ATTR_METADATA_ID está establecido en SQL_TRUE.<br/><br/>Dado que el carácter de comilla de identificador en SQL-92 es la comilla doble ("), un controlador que se ajusta estrictamente a SQL-92 siempre devolverá el carácter de comillas dobles.|
|SQL_INDEX_KEYWORDS|3.0|Una máscara de SQLUINTEGER que incluya que enumera las palabras clave en la instrucción CREATE INDEX admitidas por el controlador:<br/>SQL_IK_NONE = no se admite ninguna de las palabras clave.<br/>Se admite SQL_IK_ASC = palabra clave ASC.<br/>Se admite SQL_IK_DESC = palabra clave DESC.<br/>SQL_IK_ALL = se admiten todas las palabras clave.<br/><br/>Para ver si se admite la instrucción CREATE INDEX, una aplicación llama a **SQLGetInfo** con el tipo de información SQL_DLL_INDEX.|
|SQL_INFO_SCHEMA_VIEWS|3.0|Máscara de SQLUINTEGER que incluya que enumera las vistas en el INFORMATION_SCHEMA que son compatibles con el controlador. Las vistas en y el contenido de INFORMATION_SCHEMA son las definidas en SQL-92.<br/><br/>El nivel de conformidad con SQL-92 o FIPS en el que se debe admitir esta característica se muestra entre paréntesis junto a cada máscara de bits.<br/><br/>Las siguientes máscaras de código se usan para determinar qué vistas se admiten:<br/>SQL_ISV_ASSERTIONS = identifica las aserciones del catálogo que son propiedad de un usuario determinado. (Nivel completo)<br/>SQL_ISV_CHARACTER_SETS = identifica los juegos de caracteres del catálogo a los que puede tener acceso un usuario determinado. (Nivel intermedio)<br/>SQL_ISV_CHECK_CONSTRAINTS = identifica las restricciones CHECK que son propiedad de un usuario determinado. (Nivel intermedio)<br/>SQL_ISV_COLLATIONS = identifica las intercalaciones de caracteres para el catálogo a las que puede tener acceso un usuario determinado. (Nivel completo)<br/>SQL_ISV_COLUMN_DOMAIN_USAGE = identifica columnas para el catálogo que dependen de los dominios definidos en el catálogo y que pertenecen a un usuario determinado. (Nivel intermedio)<br/>SQL_ISV_COLUMN_PRIVILEGES = identifica los privilegios en columnas de tablas persistentes que están disponibles para un usuario determinado o que se le conceden. (Nivel de transición de FIPS)<br/>SQL_ISV_COLUMNS = identifica las columnas de las tablas persistentes a las que puede tener acceso un usuario determinado. (Nivel de transición de FIPS)<br/>SQL_ISV_CONSTRAINT_COLUMN_USAGE = similar a la vista CONSTRAINT_TABLE_USAGE, las columnas se identifican para las distintas restricciones que son propiedad de un usuario determinado. (Nivel intermedio)<br/>SQL_ISV_CONSTRAINT_TABLE_USAGE = identifica las tablas que usan las restricciones (referencia referencial, única y aserciones) y que son propiedad de un usuario determinado. (Nivel intermedio)<br/>SQL_ISV_DOMAIN_CONSTRAINTS = identifica las restricciones de dominio (de los dominios del catálogo) a las que puede tener acceso un usuario determinado. (Nivel intermedio)<br/>SQL_ISV_DOMAINS = identifica los dominios definidos en un catálogo al que puede tener acceso el usuario. (Nivel intermedio)<br/>SQL_ISV_KEY_COLUMN_USAGE = identifica las columnas definidas en el catálogo que un usuario determinado restringe como claves. (Nivel intermedio)<br/>SQL_ISV_REFERENTIAL_CONSTRAINTS = identifica las restricciones referenciales que son propiedad de un usuario determinado. (Nivel intermedio)<br/>SQL_ISV_SCHEMATA = identifica los esquemas que pertenecen a un usuario determinado. (Nivel intermedio)<br/>SQL_ISV_SQL_LANGUAGES = identifica los niveles, opciones y dialectos de compatibilidad de SQL admitidos por la implementación de SQL. (Nivel intermedio)<br/>SQL_ISV_TABLE_CONSTRAINTS = identifica las restricciones de tabla que son propiedad de un usuario determinado. (Nivel intermedio)<br/>SQL_ISV_TABLE_PRIVILEGES = identifica los privilegios en tablas persistentes que están disponibles para un usuario determinado o que se le conceden. (Nivel de transición de FIPS)<br/>SQL_ISV_TABLES = identifica las tablas persistentes definidas en un catálogo a las que puede tener acceso un usuario determinado. (Nivel de transición de FIPS)<br/>SQL_ISV_TRANSLATIONS = identifica las traducciones de caracteres para el catálogo al que puede tener acceso un usuario determinado. (Nivel completo)<br/>SQL_ISV_USAGE_PRIVILEGES = identifica los privilegios de uso de los objetos de catálogo que están disponibles para un usuario determinado o que pertenecen a él. (Nivel de transición de FIPS)<br/>SQL_ISV_VIEW_COLUMN_USAGE = identifica las columnas de las que dependen las vistas de catálogo que son propiedad de un usuario determinado. (Nivel intermedio)<br/>SQL_ISV_VIEW_TABLE_USAGE = identifica las tablas de las que dependen las vistas de catálogo que son propiedad de un usuario determinado. (Nivel intermedio)<br/>SQL_ISV_VIEWS = identifica las tablas vistas definidas en este catálogo a las que puede tener acceso un usuario determinado. (Nivel de transición de FIPS)|
|SQL_INSERT_STATEMENT|3.0|Máscara de SQLUINTEGER que incluya que indica compatibilidad con las instrucciones **Insert** :<br/>SQL_IS_INSERT_LITERALS<br/>SQL_IS_INSERT_SEARCHED<br/>SQL_IS_SELECT_INTO<br/><br/>Un controlador compatible con el nivel de entrada SQL-92 siempre devolverá todas las opciones que se admiten.|
|SQL_INTEGRITY|1.0|Una cadena de caracteres: "Y" si el origen de datos admite la utilidad de mejora de integridad; Si no es así, "N".<br/><br/>Se ha cambiado el nombre de *InfoType* a ODBC 3,0 de ODBC 2,0 *InfoType* SQL_ODBC_SQL_OPT_IEF.|
|SQL_KEYSET_CURSOR_ATTRIBUTES1|3.0|Máscara de SQLUINTEGER que incluya que describe los atributos de un cursor de conjunto de claves compatible con el controlador. Esta máscara de subred contiene el primer subconjunto de atributos; para el segundo subconjunto, consulte SQL_KEYSET_CURSOR_ATTRIBUTES2.<br/><br/>Las siguientes máscaras de código se usan para determinar los atributos que se admiten:<br/>SQL_CA1_NEXT<br/>SQL_CA1_ABSOLUTE<br/>SQL_CA1_RELATIVE<br/>SQL_CA1_BOOKMARK<br/>SQL_CA1_LOCK_EXCLUSIVE<br/>SQL_CA1_LOCK_NO_CHANGE<br/>SQL_CA1_LOCK_UNLOCK<br/>SQL_CA1_POS_POSITION<br/>SQL_CA1_POS_UPDATE<br/>SQL_CA1_POS_DELETE<br/>SQL_CA1_POS_REFRESH<br/>SQL_CA1_POSITIONED_UPDATE<br/>SQL_CA1_POSITIONED_DELETE<br/>SQL_CA1_SELECT_FOR_UPDATE<br/>SQL_CA1_BULK_ADD<br/>SQL_CA1_BULK_UPDATE_BY_BOOKMARK<br/>SQL_CA1_BULK_DELETE_BY_BOOKMARK<br/>SQL_CA1_BULK_FETCH_BY_BOOKMARK<br/><br/>Para obtener descripciones de estas máscaras de bits, vea SQL_DYNAMIC_CURSOR_ATTRIBUTES1 (y sustituir "cursor controlado por conjunto de claves" para "cursor dinámico" en las descripciones).<br/><br/>Normalmente, un controlador compatible con el nivel intermedio de SQL-92 devolverá las opciones SQL_CA1_NEXT, SQL_CA1_ABSOLUTE y SQL_CA1_RELATIVE tal como se admiten, ya que el controlador admite cursores desplazables a través de la instrucción SQL FETCH incrustada. Como esto no determina directamente la compatibilidad con SQL subyacente, no obstante, es posible que no se admitan los cursores desplazables, incluso para un controlador compatible con el nivel intermedio de SQL-92.|
|SQL_KEYSET_CURSOR_ATTRIBUTES2|3.0|Máscara de SQLUINTEGER que incluya que describe los atributos de un cursor de conjunto de claves compatible con el controlador. Esta máscara de subred contiene el segundo subconjunto de atributos; para el primer subconjunto, consulte SQL_KEYSET_CURSOR_ATTRIBUTES1.<br/><br/>Las siguientes máscaras de código se usan para determinar los atributos que se admiten:<br/>SQL_CA2_READ_ONLY_CONCURRENCY<br/>SQL_CA2_LOCK_CONCURRENCY<br/>SQL_CA2_OPT_ROWVER_CONCURRENCY<br/>SQL_CA2_OPT_VALUES_CONCURRENCY<br/>SQL_CA2_SENSITIVITY_ADDITIONS<br/>SQL_CA2_SENSITIVITY_DELETIONS<br/>SQL_CA2_SENSITIVITY_UPDATES<br/>SQL_CA2_MAX_ROWS_SELECT<br/>SQL_CA2_MAX_ROWS_INSERT<br/>SQL_CA2_MAX_ROWS_DELETE<br/>SQL_CA2_MAX_ROWS_UPDATE<br/>SQL_CA2_MAX_ROWS_CATALOG<br/>SQL_CA2_MAX_ROWS_AFFECTS_ALL<br/>SQL_CA2_CRC_EXACT<br/>SQL_CA2_CRC_APPROXIMATE<br/>SQL_CA2_SIMULATE_NON_UNIQUE<br/>SQL_CA2_SIMULATE_TRY_UNIQUE<br/>SQL_CA2_SIMULATE_UNIQUE<br/><br/>Para obtener descripciones de estas máscaras de bits, vea SQL_DYNAMIC_CURSOR_ATTRIBUTES1 (y sustituir "cursor controlado por conjunto de claves" para "cursor dinámico" en las descripciones).|
|SQL_KEYWORDS|2.0|Cadena de caracteres que contiene una lista separada por comas de todas las palabras clave específicas del origen de datos. Esta lista no contiene palabras clave específicas de ODBC o palabras clave utilizadas por el origen de datos y ODBC. Esta lista representa todas las palabras clave reservadas; las aplicaciones interoperables no deben usar estas palabras en los nombres de objeto.<br/><br/>Para obtener una lista de las palabras clave de ODBC, vea [palabras clave reservadas](../appendixes/reserved-keywords.md) en el [Apéndice C: gramática de SQL](../appendixes/appendix-c-sql-grammar.md). El valor de **#define** SQL_ODBC_KEYWORDS contiene una lista separada por comas de palabras clave de ODBC.|
|SQL_LIKE_ESCAPE_CLAUSE|2.0|Una cadena de caracteres: "Y" si el origen de datos admite un carácter de escape para el carácter de porcentaje (%) y el carácter de subrayado (_) en un predicado **like** y el controlador admite la sintaxis de ODBC para definir un carácter de escape de predicado **like** ; "N" en caso contrario.|
|SQL_MAX_ASYNC_CONCURRENT_STATEMENTS|3.0|Un valor SQLUINTEGER que incluya que especifica el número máximo de instrucciones simultáneas activas en modo asincrónico que el controlador puede admitir en una conexión determinada. Si no hay ningún límite específico o se desconoce el límite, este valor es cero.|
|SQL_MAX_BINARY_LITERAL_LEN|2.0|Un valor SQLUINTEGER que incluya que especifica la longitud máxima (número de caracteres hexadecimales, sin incluir el prefijo y sufijo literal devuelto por **SQLGetTypeInfo**) de un literal binario en una instrucción SQL. Por ejemplo, el literal binario 0xFFAA tiene una longitud de 4. Si no hay ninguna longitud máxima o se desconoce la longitud, este valor se establece en cero.|
|SQL_MAX_CATALOG_NAME_LEN|1.0|Valor SQLUSMALLINT que especifica la longitud máxima de un nombre de catálogo en el origen de datos. Si no hay ninguna longitud máxima o se desconoce la longitud, este valor se establece en cero.<br/><br/>Un controlador compatible con el nivel estándar FIPS devolverá al menos 128.<br/><br/>Se ha cambiado el nombre de *InfoType* a ODBC 3,0 de ODBC 2,0 *InfoType* SQL_MAX_QUALIFIER_NAME_LEN.|
|SQL_MAX_CHAR_LITERAL_LEN|2.0|Un valor SQLUINTEGER que incluya que especifica la longitud máxima (número de caracteres, excluyendo el prefijo y sufijo literal devuelto por **SQLGetTypeInfo**) de un literal de carácter en una instrucción SQL. Si no hay ninguna longitud máxima o se desconoce la longitud, este valor se establece en cero.|
|SQL_MAX_COLUMN_NAME_LEN|1.0|Valor SQLUSMALLINT que especifica la longitud máxima de un nombre de columna en el origen de datos. Si no hay ninguna longitud máxima o se desconoce la longitud, este valor se establece en cero.<br/><br/>Un controlador compatible con el nivel de entrada FIPS devolverá al menos 18. Un controlador compatible con el nivel intermedio FIPS devolverá al menos 128.|
|SQL_MAX_COLUMNS_IN_GROUP_BY|2.0|Valor SQLUSMALLINT que especifica el número máximo de columnas permitidas en una cláusula **Group by** . Si no hay ningún límite especificado o se desconoce el límite, este valor se establece en cero.<br/><br/>Un controlador compatible con el nivel de entrada FIPS devolverá al menos 6. Un controlador compatible con el nivel intermedio FIPS devolverá al menos 15.|
|SQL_MAX_COLUMNS_IN_INDEX|2.0|Valor SQLUSMALLINT que especifica el número máximo de columnas permitido en un índice. Si no hay ningún límite especificado o se desconoce el límite, este valor se establece en cero.|
|SQL_MAX_COLUMNS_IN_ORDER_BY|2.0|Valor SQLUSMALLINT que especifica el número máximo de columnas permitidas en una cláusula **order by** . Si no hay ningún límite especificado o se desconoce el límite, este valor se establece en cero.<br/><br/>Un controlador compatible con el nivel de entrada FIPS devolverá al menos 6. Un controlador compatible con el nivel intermedio FIPS devolverá al menos 15.|
|SQL_MAX_COLUMNS_IN_SELECT|2.0|Valor SQLUSMALLINT que especifica el número máximo de columnas permitidas en una lista de selección. Si no hay ningún límite especificado o se desconoce el límite, este valor se establece en cero.<br/><br/>Un controlador compatible con el nivel de entrada FIPS devolverá al menos 100. Un controlador compatible con el nivel intermedio FIPS devolverá al menos 250.|
|SQL_MAX_COLUMNS_IN_TABLE|2.0|Valor SQLUSMALLINT que especifica el número máximo de columnas permitidas en una tabla. Si no hay ningún límite especificado o se desconoce el límite, este valor se establece en cero.<br/><br/>Un controlador compatible con el nivel de entrada FIPS devolverá al menos 100. Un controlador compatible con el nivel intermedio FIPS devolverá al menos 250.|
|SQL_MAX_CONCURRENT_ACTIVITIES|1.0|Un valor SQLUSMALLINT que especifica el número máximo de instrucciones activas que el controlador puede admitir para una conexión. Una instrucción se define como Active si tiene resultados pendientes, con el término "Results", lo que significa filas de una operación **Select** o filas afectadas por una operación de **inserción**, **actualización** o **eliminación** (como un recuento de filas) o si se encuentra en un estado NEED_DATA. Este valor puede reflejar una limitación impuesta por el controlador o el origen de datos. Si no hay ningún límite especificado o se desconoce el límite, este valor se establece en cero.<br/><br/>Se ha cambiado el nombre de *InfoType* a ODBC 3,0 de ODBC 2,0 *InfoType* SQL_ACTIVE_STATEMENTS.|
|SQL_MAX_CURSOR_NAME_LEN|1.0|Valor SQLUSMALLINT que especifica la longitud máxima de un nombre de cursor en el origen de datos. Si no hay ninguna longitud máxima o se desconoce la longitud, este valor se establece en cero.<br/><br/>Un controlador compatible con el nivel de entrada FIPS devolverá al menos 18. Un controlador compatible con el nivel intermedio FIPS devolverá al menos 128.|
|SQL_MAX_DRIVER_CONNECTIONS|1.0|Un valor SQLUSMALLINT que especifica el número máximo de conexiones activas que el controlador puede admitir para un entorno. Este valor puede reflejar una limitación impuesta por el controlador o el origen de datos. Si no hay ningún límite especificado o se desconoce el límite, este valor se establece en cero.<br/><br/>Se ha cambiado el nombre de *InfoType* a ODBC 3,0 de ODBC 2,0 *InfoType* SQL_ACTIVE_CONNECTIONS.|
|SQL_MAX_IDENTIFIER_LEN|3.0|SQLUSMALLINT que indica el tamaño máximo en caracteres que admite el origen de datos para los nombres definidos por el usuario.<br/><br/>Un controlador compatible con el nivel de entrada FIPS devolverá al menos 18. Un controlador compatible con el nivel intermedio FIPS devolverá al menos 128.|
|SQL_MAX_INDEX_SIZE|2.0|Valor SQLUINTEGER que incluya que especifica el número máximo de bytes permitidos en los campos combinados de un índice. Si no hay ningún límite especificado o se desconoce el límite, este valor se establece en cero.|
|SQL_MAX_PROCEDURE_NAME_LEN|1.0|Valor SQLUSMALLINT que especifica la longitud máxima de un nombre de procedimiento en el origen de datos. Si no hay ninguna longitud máxima o se desconoce la longitud, este valor se establece en cero.|
|SQL_MAX_ROW_SIZE|2.0|Valor SQLUINTEGER que incluya que especifica la longitud máxima de una sola fila de una tabla. Si no hay ningún límite especificado o se desconoce el límite, este valor se establece en cero.<br/><br/>Un controlador compatible con el nivel de entrada FIPS devolverá al menos 2.000. Un controlador compatible con el nivel intermedio FIPS devolverá al menos 8.000.|
|SQL_MAX_ROW_SIZE_INCLUDES_LONG|3.0|Una cadena de caracteres: "Y" si el tamaño de fila máximo devuelto para el tipo de información SQL_MAX_ROW_SIZE incluye la longitud de todas las columnas SQL_LONGVARCHAR y SQL_LONGVARBINARY de la fila; "N" en caso contrario.|
|SQL_MAX_SCHEMA_NAME_LEN|1.0|Valor SQLUSMALLINT que especifica la longitud máxima de un nombre de esquema en el origen de datos. Si no hay ninguna longitud máxima o se desconoce la longitud, este valor se establece en cero.<br/><br/>Un controlador compatible con el nivel de entrada FIPS devolverá al menos 18. Un controlador compatible con el nivel intermedio FIPS devolverá al menos 128.<br/><br/>Se ha cambiado el nombre de *InfoType* a ODBC 3,0 de ODBC 2,0 *InfoType* SQL_MAX_OWNER_NAME_LEN.|
|SQL_MAX_STATEMENT_LEN|2.0|Valor SQLUINTEGER que incluya que especifica la longitud máxima (número de caracteres, incluido el espacio en blanco) de una instrucción SQL. Si no hay ninguna longitud máxima o se desconoce la longitud, este valor se establece en cero.|
|SQL_MAX_TABLE_NAME_LEN|1.0|Valor SQLUSMALLINT que especifica la longitud máxima de un nombre de tabla en el origen de datos. Si no hay ninguna longitud máxima o se desconoce la longitud, este valor se establece en cero.<br/><br/>Un controlador compatible con el nivel de entrada FIPS devolverá al menos 18. Un controlador compatible con el nivel intermedio FIPS devolverá al menos 128.|
|SQL_MAX_TABLES_IN_SELECT|2.0|Valor SQLUSMALLINT que especifica el número máximo de tablas permitidas en la cláusula **from** de una instrucción **Select** . Si no hay ningún límite especificado o se desconoce el límite, este valor se establece en cero.<br/><br/>Un controlador compatible con el nivel de entrada FIPS devolverá al menos 15. Un controlador compatible con el nivel intermedio FIPS devolverá al menos 50.|
|SQL_MAX_USER_NAME_LEN|2.0|Valor SQLUSMALLINT que especifica la longitud máxima de un nombre de usuario en el origen de datos. Si no hay ninguna longitud máxima o se desconoce la longitud, este valor se establece en cero.|
|SQL_MULT_RESULT_SETS|1.0|Una cadena de caracteres: "Y" si el origen de datos admite varios conjuntos de resultados, "N" si no es así.<br/><br/>Para obtener más información sobre varios conjuntos de resultados, vea [varios resultados](../develop-app/multiple-results.md).|
|SQL_MULTIPLE_ACTIVE_TXN|1.0|Una cadena de caracteres: "Y" si el controlador admite más de una transacción activa al mismo tiempo, "N" si solo puede haber una transacción activa en cualquier momento.<br/><br/>La información devuelta para este tipo de información no se aplica en el caso de las transacciones distribuidas.|
|SQL_NEED_LONG_DATA_LEN|2.0|Una cadena de caracteres: "Y" si el origen de datos necesita la longitud de un valor de datos largo (el tipo de datos es SQL_LONGVARCHAR, SQL_LONGVARBINARY o un tipo de datos específico de origen de datos) antes de que se envíe el valor al origen de datos, "N" si no existe. Para obtener más información, vea la función [SQLBindParameter](sqlbindparameter-function.md) y la [función SQLSetPos](sqlsetpos-function.md).|
|SQL_NON_NULLABLE_COLUMNS|1.0|Un valor SQLUSMALLINT que especifica si el origen de datos admite NOT NULL en las columnas:<br/>SQL_NNC_NULL = todas las columnas deben admitir valores NULL.<br/>SQL_NNC_NON_NULL = las columnas no pueden aceptar valores NULL. (El origen de datos admite la restricción de columna **not null** en las instrucciones **CREATE TABLE** ).<br/><br/>Un controlador compatible con el nivel de entrada SQL-92 devolverá SQL_NNC_NON_NULL.|
|SQL_NULL_COLLATION|2.0|Un valor SQLUSMALLINT que especifica dónde se ordenan los valores NULL en un conjunto de resultados:<br/>SQL_NC_END = los valores NULL se ordenan al final del conjunto de resultados, independientemente de las palabras clave ASC o DESC.<br/>SQL_NC_HIGH = los valores NULL se ordenan en el extremo superior del conjunto de resultados, en función de las palabras clave ASC o DESC.<br/>SQL_NC_LOW = los valores NULL se ordenan en el extremo inferior del conjunto de resultados, en función de las palabras clave ASC o DESC.<br/>SQL_NC_START = los valores NULL se ordenan al principio del conjunto de resultados, independientemente de las palabras clave ASC o DESC.|
|SQL_NUMERIC_FUNCTIONS|1.0|Nota: el tipo de información se incorporó en ODBC 1,0; cada máscara de máscara tiene la etiqueta de la versión en la que se presentó.<br/><br/>Una máscara de SQLUINTEGER que incluya que enumera las funciones numéricas escalares admitidas por el controlador y el origen de datos asociado.<br/><br/>Las siguientes máscaras de código se usan para determinar qué funciones numéricas se admiten:<br/>SQL_FN_NUM_ABS (ODBC 1,0)<br/>SQL_FN_NUM_ACOS (ODBC 1,0)<br/>SQL_FN_NUM_ASIN (ODBC 1,0)<br/>SQL_FN_NUM_ATAN (ODBC 1,0)<br/>SQL_FN_NUM_ATAN2 (ODBC 1,0)<br/>SQL_FN_NUM_CEILING (ODBC 1,0)<br/>SQL_FN_NUM_COS (ODBC 1,0)<br/>SQL_FN_NUM_COT (ODBC 1,0)<br/>SQL_FN_NUM_DEGREES (ODBC 2,0)<br/>SQL_FN_NUM_EXP (ODBC 1,0)<br/>SQL_FN_NUM_FLOOR (ODBC 1,0)<br/>SQL_FN_NUM_LOG (ODBC 1,0)<br/>SQL_FN_NUM_LOG10 (ODBC 2,0)<br/>SQL_FN_NUM_MOD (ODBC 1,0)<br/>SQL_FN_NUM_PI (ODBC 1,0)<br/>SQL_FN_NUM_POWER (ODBC 2,0)<br/>SQL_FN_NUM_RADIANS (ODBC 2,0)<br/>SQL_FN_NUM_RAND (ODBC 1,0)<br/>SQL_FN_NUM_ROUND (ODBC 2,0)<br/>SQL_FN_NUM_SIGN (ODBC 1,0)<br/>SQL_FN_NUM_SIN (ODBC 1,0)<br/>SQL_FN_NUM_SQRT (ODBC 1,0)<br/>SQL_FN_NUM_TAN (ODBC 1,0)<br/>SQL_FN_NUM_TRUNCATE (ODBC 2,0)|
|SQL_ODBC_INTERFACE_CONFORMANCE|3.0|Un valor SQLUINTEGER que incluya que indica el nivel de la interfaz ODBC 3 *. x* que el controlador cumple.<br/><br/>SQL_OIC_CORE: el nivel mínimo que se espera que cumplan todos los controladores ODBC. Este nivel incluye elementos básicos de la interfaz, como funciones de conexión, funciones para preparar y ejecutar una instrucción SQL, funciones básicas de metadatos del conjunto de resultados, funciones de catálogo básicas, etc.<br/>SQL_OIC_LEVEL1: un nivel que incluye la funcionalidad del nivel de compatibilidad de los estándares principales, más cursores desplazables, marcadores, actualizaciones y eliminaciones posicionadas, etc.<br/>SQL_OIC_LEVEL2: un nivel que incluye la funcionalidad del nivel de cumplimiento de los estándares de nivel 1, además de características avanzadas como cursores confidenciales; actualizar, eliminar y actualizar por marcadores; compatibilidad con procedimientos almacenados; funciones de catálogo para claves principales y externas; compatibilidad con varios catálogos; etc.<br/><br/>Para obtener más información, consulte [niveles de cumplimiento](../develop-app/interface-conformance-levels.md)de la interfaz.|
|SQL_ODBC_VER|1.0|Cadena de caracteres con la versión de ODBC a la que se ajusta el administrador de controladores. La versión tiene el formato # #. # #. 0000, donde los dos primeros dígitos son la versión principal y los dos dígitos siguientes son la versión secundaria. Esto solo se implementa en el administrador de controladores.|
|SQL_OJ_CAPABILITIES|2,01|Una máscara de SQLUINTEGER que incluya que enumera los tipos de combinaciones externas admitidas por el controlador y el origen de datos. Las siguientes máscaras de código se usan para determinar qué tipos se admiten:<br/>SQL_OJ_LEFT = se admiten las combinaciones externas izquierdas.<br/>SQL_OJ_RIGHT = se admiten las combinaciones externas correctas.<br/>SQL_OJ_FULL = se admiten combinaciones externas completas.<br/>SQL_OJ_NESTED = se admiten combinaciones externas anidadas.<br/>SQL_OJ_NOT_ORDERED = los nombres de columna de la cláusula ON de la combinación externa no tienen que estar en el mismo orden que sus respectivos nombres de tabla en la cláusula **outer join** .<br/>SQL_OJ_INNER = la tabla interna (la tabla derecha de una combinación externa izquierda o la tabla izquierda en una combinación externa derecha) también se puede usar en una combinación interna. Esto no se aplica a las combinaciones externas completas, que no tienen una tabla interna.<br/>SQL_OJ_ALL_COMPARISON_OPS = el operador de comparación de la cláusula ON puede ser cualquiera de los operadores de comparación de ODBC. Si no se establece este bit, solo se puede usar el operador de comparación es igual a (=) en combinaciones externas.<br/><br/>Si ninguna de estas opciones se devuelve como compatible, no se admite ninguna cláusula de combinación externa.<br/><br/>Para obtener información sobre la compatibilidad de los operadores de combinación relacional en una instrucción SELECT, como se define en SQL-92, vea SQL_SQL92_RELATIONAL_JOIN_OPERATORS.|
|SQL_ORDER_BY_COLUMNS_IN_SELECT|2.0|Una cadena de caracteres: "Y" si las columnas de la cláusula **order by** deben estar en la lista de selección; de lo contrario, "N".|
|SQL_PARAM_ARRAY_ROW_COUNTS|3.0|SQLUINTEGER que incluya que enumera las propiedades del controlador con respecto a la disponibilidad de recuentos de filas en una ejecución parametrizada. Tiene los siguientes valores:<br/>SQL_PARC_BATCH = recuentos de filas individuales están disponibles para cada conjunto de parámetros. Es conceptualmente equivalente al controlador que genera un lote de instrucciones SQL, uno para cada conjunto de parámetros de la matriz. La información de error extendida se puede recuperar mediante el SQL_PARAM_STATUS_PTR Campo descriptor.<br/>SQL_PARC_NO_BATCH = solo hay un número de filas disponible, que es el recuento acumulado de filas resultante de la ejecución de la instrucción para toda la matriz de parámetros. Es conceptualmente equivalente a tratar la instrucción junto con la matriz de parámetros completa como una unidad atómica. Los errores se controlan igual que si se ejecutara una instrucción.|
|SQL_PARAM_ARRAY_SELECTS|3.0|SQLUINTEGER que incluya que enumera las propiedades del controlador con respecto a la disponibilidad de los conjuntos de resultados en una ejecución parametrizada. Tiene los siguientes valores:<br/>SQL_PAS_BATCH = hay un conjunto de resultados disponible por cada conjunto de parámetros. Es conceptualmente equivalente al controlador que genera un lote de instrucciones SQL, uno para cada conjunto de parámetros de la matriz.<br/>SQL_PAS_NO_BATCH = solo hay un conjunto de resultados disponible, que representa el conjunto de resultados acumulado resultante de la ejecución de la instrucción para la matriz completa de parámetros. Es conceptualmente equivalente a tratar la instrucción junto con la matriz de parámetros completa como una unidad atómica.<br/>SQL_PAS_NO_SELECT = un controlador no permite que se ejecute una instrucción de generación de conjuntos de resultados con una matriz de parámetros.|
|SQL_POS_OPERATIONS|2.0|Una máscara de SQLINTEGER donde que enumera las operaciones de soporte en **SQLSetPos**.<br/><br/>Las siguientes máscaras de código se usan junto con la marca para determinar qué opciones se admiten.<br/>SQL_POS_POSITION (ODBC 2,0)<br/>SQL_POS_REFRESH (ODBC 2,0)<br/>SQL_POS_UPDATE (ODBC 2,0)<br/>SQL_POS_DELETE (ODBC 2,0)<br/>SQL_POS_ADD (ODBC 2,0)|
|SQL_PROCEDURE_TERM|1.0|Cadena de caracteres con el nombre del proveedor del origen de datos para un procedimiento; por ejemplo, "procedimiento de base de datos", "procedimiento almacenado", "procedimiento", "paquete" o "consulta almacenada".|
|SQL_PROCEDURES|1.0|Cadena de caracteres: "Y" si el origen de datos admite procedimientos y el controlador admite la sintaxis de invocación de procedimiento ODBC; "N" en caso contrario.|
|SQL_QUOTED_IDENTIFIER_CASE|2.0|Un valor de SQLUSMALLINT como se indica a continuación:<br/>SQL_IC_UPPER = los identificadores entre comillas en SQL no distinguen mayúsculas de minúsculas y se almacenan en mayúsculas en el catálogo del sistema.<br/>SQL_IC_LOWER = los identificadores entre comillas en SQL no distinguen mayúsculas de minúsculas y se almacenan en minúsculas en el catálogo del sistema.<br/>SQL_IC_SENSITIVE = los identificadores entre comillas en SQL distinguen mayúsculas de minúsculas y se almacenan en mayúsculas y minúsculas mezcladas en el catálogo del sistema. (En una base de datos compatible con SQL-92, los identificadores entre comillas siempre distinguen mayúsculas de minúsculas).<br/>SQL_IC_MIXED = los identificadores entre comillas en SQL no distinguen mayúsculas de minúsculas y se almacenan en mayúsculas y minúsculas mezcladas en el catálogo del sistema.<br/><br/>Un controlador compatible con el nivel de entrada SQL-92 siempre devolverá SQL_IC_SENSITIVE.|
|SQL_ROW_UPDATES|1.0|Una cadena de caracteres: "Y" Si un cursor controlado por conjunto de claves o mixto mantiene las versiones de fila o los valores de todas las filas capturadas y, por tanto, puede detectar cualquier actualización realizada en una fila por cualquier usuario desde la última vez que se recuperó la fila. (Esto solo se aplica a las actualizaciones, no a las eliminaciones o inserciones). El controlador puede devolver la marca de SQL_ROW_UPDATED a la matriz de estado de fila cuando se llama a **SQLFetchScroll** . De lo contrario, "N".|
|SQL_SCHEMA_TERM|1.0|Cadena de caracteres con el nombre del proveedor del origen de datos para un esquema; por ejemplo, "Owner", "Authorization ID" o "Schema".<br/><br/>La cadena de caracteres se puede devolver en mayúsculas, minúsculas o mezcladas.<br/><br/>Un controlador compatible con el nivel de entrada SQL-92 siempre devolverá el "esquema".<br/><br/>Se ha cambiado el nombre de *InfoType* a ODBC 3,0 de ODBC 2,0 *InfoType* SQL_OWNER_TERM.|
|SQL_SCHEMA_USAGE|2.0|Una máscara de SQLUINTEGER que incluya que enumera las instrucciones en las que se pueden usar esquemas:<br/>SQL_SU_DML_STATEMENTS = los esquemas se admiten en todas las instrucciones de lenguaje de manipulación de datos: **Select**, **Insert**, **Update**, **Delete** y, si se admite, **Seleccione para** las instrucciones Update y posicionada Update y DELETE.<br/>SQL_SU_PROCEDURE_INVOCATION = los esquemas se admiten en la instrucción de invocación de procedimiento ODBC.<br/>SQL_SU_TABLE_DEFINITION = los esquemas se admiten en todas las instrucciones de definición de tabla: **CREATE TABLE**, **Create View**, **ALTER TABLE**, **DROP TABLE** y **Drop View**.<br/>SQL_SU_INDEX_DEFINITION = los esquemas se admiten en todas las instrucciones de definición de índice: **Create index** y **Drop index**.<br/>SQL_SU_PRIVILEGE_DEFINITION = los esquemas se admiten en todas las instrucciones de definición de privilegios: **Grant** y **REVOKE**.<br/><br/>Un controlador compatible con el nivel de entrada SQL-92 siempre devolverá las opciones SQL_SU_DML_STATEMENTS, SQL_SU_TABLE_DEFINITION y SQL_SU_PRIVILEGE_DEFINITION, como se admiten.<br/><br/>Se ha cambiado el nombre de *InfoType* a ODBC 3,0 de ODBC 2,0 *InfoType* SQL_OWNER_USAGE.|
|SQL_SCROLL_OPTIONS|1.0|Nota: el tipo de información se incorporó en ODBC 1,0; cada máscara de máscara tiene la etiqueta de la versión en la que se presentó.<br/><br/>Una máscara de SQLUINTEGER que incluya que enumera las opciones de desplazamiento admitidas para los cursores desplazables.<br/><br/>Las siguientes máscaras de código se usan para determinar qué opciones se admiten:<br/>SQL_SO_FORWARD_ONLY = el cursor solo se desplaza hacia delante. (ODBC 1,0)<br/>SQL_SO_STATIC = los datos del conjunto de resultados son estáticos. (ODBC 2,0)<br/>SQL_SO_KEYSET_DRIVEN = el controlador guarda y usa las claves para cada fila del conjunto de resultados. (ODBC 1,0)<br/>SQL_SO_DYNAMIC = el controlador mantiene las claves para cada fila del conjunto de filas (el tamaño del conjunto de claves es igual que el tamaño del conjunto de filas). (ODBC 1,0)<br/>SQL_SO_MIXED = el controlador mantiene las claves para cada fila del conjunto de claves y el tamaño del conjunto de claves es mayor que el tamaño del conjunto de filas. El cursor está controlado por conjunto de claves dentro del conjunto de claves y dinámico fuera del conjunto de claves. (ODBC 1,0)<br/><br/>Para obtener información acerca de los cursores desplazables, vea [cursores desplazables](../develop-app/scrollable-cursors.md).|
|SQL_SEARCH_PATTERN_ESCAPE|1.0|Una cadena de caracteres que especifica lo que el controlador admite como un carácter de escape que permite el uso de los metacaracteres de coincidencia de patrones de subrayado (_) y el signo de porcentaje (%) como caracteres válidos en los patrones de búsqueda. Este carácter de escape solo se aplica a los argumentos de la función de catálogo que admiten cadenas de búsqueda. Si esta cadena está vacía, el controlador no admite un carácter de escape de patrón de búsqueda.<br/><br/>Dado que este tipo de información no indica la compatibilidad general del carácter de escape en el predicado **like** , SQL-92 no incluye los requisitos de esta cadena de caracteres.<br/><br/>Este *InfoType* se limita a las funciones de catálogo. Para obtener una descripción del uso del carácter de escape en las cadenas de patrón de búsqueda, vea [argumentos de valor de patrón](../develop-app/pattern-value-arguments.md).|
|SQL_SERVER_NAME|1.0|Cadena de caracteres con el nombre real del servidor específico del origen de datos; resulta útil cuando se utiliza un nombre de origen de datos durante **SQLConnect**, **SQLDriverConnect** y **SQLBrowseConnect**.|
|SQL_SPECIAL_CHARACTERS|2.0|Cadena de caracteres que contiene todos los caracteres especiales (es decir, todos los caracteres excepto de la a a la z, de la a a la Z, de 0 a 9 y de subrayado) que se pueden usar en un nombre de identificador, como un nombre de tabla, nombre de columna o nombre de índice, en el origen de datos. Por ejemplo, "# $ ^". Si un identificador contiene uno o varios de estos caracteres, el identificador debe ser un identificador delimitado.|
|SQL_SQL_CONFORMANCE|3.0|Un valor SQLUINTEGER que incluya que indica el nivel de SQL-92 compatible con el controlador:<br/>SQL_SC_SQL92_ENTRY = nivel de entrada compatible con SQL-92.<br/>SQL_SC_FIPS127_2_TRANSITIONAL = compatible con el nivel de transición FIPS 127-2.<br/>SQL_SC_SQL92_FULL = compatible con SQL-92 de nivel completo.<br/>SQL_SC_ SQL92_INTERMEDIATE = compatible con SQL-92 de nivel intermedio.|
|SQL_SQL92_DATETIME_FUNCTIONS|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las funciones escalares de fecha y hora que son compatibles con el controlador y el origen de datos asociado, tal y como se define en SQL-92.<br/><br/>Las siguientes máscaras de código se usan para determinar qué funciones DateTime se admiten:<br/>SQL_SDF_CURRENT_DATE<br/>SQL_SDF_CURRENT_TIME<br/>SQL_SDF_CURRENT_TIMESTAMP|
|SQL_SQL92_FOREIGN_KEY_DELETE_RULE|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las reglas admitidas para una clave externa en una instrucción **Delete** , tal como se define en SQL-92.<br/><br/>Las siguientes máscaras de código se usan para determinar qué cláusulas son compatibles con el origen de datos:<br/>SQL_SFKD_CASCADE<br/>SQL_SFKD_NO_ACTION<br/>SQL_SFKD_SET_DEFAULT<br/>SQL_SFKD_SET_NULL<br/><br/>Un controlador compatible con el nivel de transición FIPS siempre devolverá todas las opciones que se admiten.|
|SQL_SQL92_FOREIGN_KEY_UPDATE_RULE|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las reglas admitidas para una clave externa en una instrucción **Update** , tal y como se define en SQL-92.<br/><br/>Las siguientes máscaras de código se usan para determinar qué cláusulas son compatibles con el origen de datos:<br/>SQL_SFKU_CASCADE<br/>SQL_SFKU_NO_ACTION<br/>SQL_SFKU_SET_DEFAULT<br/>SQL_SFKU_SET_NULL<br/><br/>Un controlador compatible con el nivel completo de SQL-92 siempre devolverá todas las opciones que se admiten.|
|SQL_SQL92_GRANT|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las cláusulas admitidas en la instrucción **Grant** , tal como se define en SQL-92.<br/><br/>El nivel de conformidad con SQL-92 o FIPS en el que se debe admitir esta característica se muestra entre paréntesis junto a cada máscara de bits.<br/><br/>Las siguientes máscaras de código se usan para determinar qué cláusulas son compatibles con el origen de datos:<br/>SQL_SG_DELETE_TABLE (nivel de entrada)<br/>SQL_SG_INSERT_COLUMN (nivel intermedio)<br/>SQL_SG_INSERT_TABLE (nivel de entrada)<br/>SQL_SG_REFERENCES_TABLE (nivel de entrada)<br/>SQL_SG_REFERENCES_COLUMN (nivel de entrada)<br/>SQL_SG_SELECT_TABLE (nivel de entrada)<br/>SQL_SG_UPDATE_COLUMN (nivel de entrada)<br/>SQL_SG_UPDATE_TABLE (nivel de entrada)<br/>SQL_SG_USAGE_ON_DOMAIN (nivel de transición de FIPS)<br/>SQL_SG_USAGE_ON_CHARACTER_SET (nivel de transición de FIPS)<br/>SQL_SG_USAGE_ON_COLLATION (nivel de transición de FIPS)<br/>SQL_SG_USAGE_ON_TRANSLATION (nivel de transición de FIPS)<br/>SQL_SG_WITH_GRANT_OPTION (nivel de entrada)|
|SQL_SQL92_NUMERIC_VALUE_FUNCTIONS|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las funciones escalares de valores numéricos admitidas por el controlador y el origen de datos asociado, tal y como se define en SQL-92.<br/><br/>Las siguientes máscaras de código se usan para determinar qué funciones numéricas se admiten:<br/>SQL_SNVF_BIT_LENGTH<br/>SQL_SNVF_CHAR_LENGTH<br/>SQL_SNVF_CHARACTER_LENGTH<br/>SQL_SNVF_EXTRACT<br/>SQL_SNVF_OCTET_LENGTH<br/>SQL_SNVF_POSITION|
|SQL_SQL92_PREDICATES|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera los predicados admitidos en una instrucción **Select** , tal como se define en SQL-92.<br/><br/>El nivel de conformidad con SQL-92 o FIPS en el que se debe admitir esta característica se muestra entre paréntesis junto a cada máscara de bits.<br/><br/>Las siguientes máscaras de código se usan para determinar las opciones que admite el origen de datos:<br/>SQL_SP_BETWEEN (nivel de entrada)<br/>SQL_SP_COMPARISON (nivel de entrada)<br/>SQL_SP_EXISTS (nivel de entrada)<br/>SQL_SP_IN (nivel de entrada)<br/>SQL_SP_ISNOTNULL (nivel de entrada)<br/>SQL_SP_ISNULL (nivel de entrada)<br/>SQL_SP_LIKE (nivel de entrada)<br/>SQL_SP_MATCH_FULL (nivel completo)<br/>SQL_SP_MATCH_PARTIAL (nivel completo)<br/>SQL_SP_MATCH_UNIQUE_FULL (nivel completo)<br/>SQL_SP_MATCH_UNIQUE_PARTIAL (nivel completo)<br/>SQL_SP_OVERLAPS (nivel de transición de FIPS)<br/>SQL_SP_QUANTIFIED_COMPARISON (nivel de entrada)<br/>SQL_SP_UNIQUE (nivel de entrada)|
|SQL_SQL92_RELATIONAL_JOIN_OPERATORS|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera los operadores de combinación relacional admitidos en una instrucción **Select** , tal como se define en SQL-92.<br/><br/>El nivel de conformidad con SQL-92 o FIPS en el que se debe admitir esta característica se muestra entre paréntesis junto a cada máscara de bits.<br/><br/>Las siguientes máscaras de código se usan para determinar las opciones que admite el origen de datos:<br/>SQL_SRJO_CORRESPONDING_CLAUSE (nivel intermedio)<br/>SQL_SRJO_CROSS_JOIN (nivel completo)<br/>SQL_SRJO_EXCEPT_JOIN (nivel intermedio)<br/>SQL_SRJO_FULL_OUTER_JOIN (nivel intermedio)<br/>SQL_SRJO_INNER_JOIN (nivel de transición de FIPS)<br/>SQL_SRJO_INTERSECT_JOIN (nivel intermedio)<br/>SQL_SRJO_LEFT_OUTER_JOIN (nivel de transición de FIPS)<br/>SQL_SRJO_NATURAL_JOIN (nivel de transición de FIPS)<br/>SQL_SRJO_RIGHT_OUTER_JOIN (nivel de transición de FIPS)<br/>SQL_SRJO_UNION_JOIN (nivel completo)<br/><br/>SQL_SRJO_INNER_JOIN indica compatibilidad con la sintaxis de **combinación interna** , no con la funcionalidad de combinación interna. La compatibilidad con la sintaxis de **combinación interna** es la transición de FIPS, mientras que la compatibilidad con la funcionalidad de combinación interna es **entry**.|
|SQL_SQL92_REVOKE|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las cláusulas admitidas en la instrucción **REVOKE** , tal como se define en SQL-92, admitidas por el origen de datos.<br/><br/>El nivel de conformidad con SQL-92 o FIPS en el que se debe admitir esta característica se muestra entre paréntesis junto a cada máscara de bits.<br/><br/>Las siguientes máscaras de código se usan para determinar qué cláusulas son compatibles con el origen de datos:<br/>SQL_SR_CASCADE (nivel de transición de FIPS)<br/>SQL_SR_DELETE_TABLE (nivel de entrada)<br/>SQL_SR_GRANT_OPTION_FOR (nivel intermedio)<br/>SQL_SR_INSERT_COLUMN (nivel intermedio)<br/>SQL_SR_INSERT_TABLE (nivel de entrada)<br/>SQL_SR_REFERENCES_COLUMN (nivel de entrada)<br/>SQL_SR_REFERENCES_TABLE (nivel de entrada)<br/>SQL_SR_RESTRICT (nivel de transición de FIPS)<br/>SQL_SR_SELECT_TABLE (nivel de entrada)<br/>SQL_SR_UPDATE_COLUMN (nivel de entrada)<br/>SQL_SR_UPDATE_TABLE (nivel de entrada)<br/>SQL_SR_USAGE_ON_DOMAIN (nivel de transición de FIPS)<br/>SQL_SR_USAGE_ON_CHARACTER_SET (nivel de transición de FIPS)<br/>SQL_SR_USAGE_ON_COLLATION (nivel de transición de FIPS)<br/>SQL_SR_USAGE_ON_TRANSLATION (nivel de transición de FIPS)|
|SQL_SQL92_ROW_VALUE_CONSTRUCTOR|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las expresiones de constructor de valores de fila admitidas en una instrucción **Select** , tal como se define en SQL-92. Las siguientes máscaras de código se usan para determinar las opciones que admite el origen de datos:<br/>SQL_SRVC_VALUE_EXPRESSION<br/>SQL_SRVC_NULL<br/>SQL_SRVC_DEFAULT<br/>SQL_SRVC_ROW_SUBQUERY|
|SQL_SQL92_STRING_FUNCTIONS|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las funciones escalares de cadena admitidas por el controlador y el origen de datos asociado, tal y como se define en SQL-92.<br/><br/>Las siguientes máscaras de código se usan para determinar qué funciones de cadena se admiten:<br/>SQL_SSF_CONVERT<br/>SQL_SSF_LOWERSQL_SSF_UPPER<br/>SQL_SSF_SUBSTRING<br/>SQL_SSF_TRANSLATE<br/>SQL_SSF_TRIM_BOTH<br/>SQL_SSF_TRIM_LEADING<br/>SQL_SSF_TRIM_TRAILING|
|SQL_SQL92_VALUE_EXPRESSIONS|3.0|Una máscara de bits SQLUINTEGER que incluya que enumera las expresiones de valor admitidas, tal como se define en SQL-92.<br/><br/>El nivel de conformidad con SQL-92 o FIPS en el que se debe admitir esta característica se muestra entre paréntesis junto a cada máscara de bits.<br/><br/>Las siguientes máscaras de código se usan para determinar las opciones que admite el origen de datos:<br/>SQL_SVE_CASE (nivel intermedio)<br/>SQL_SVE_CAST (nivel de transición de FIPS)<br/>SQL_SVE_COALESCE (nivel intermedio)<br/>SQL_SVE_NULLIF (nivel intermedio)|
|SQL_STANDARD_CLI_CONFORMANCE|3.0|Una máscara de SQLUINTEGER que incluya que enumera el estándar o los estándares de la CLI a los que se ajusta el controlador. Las siguientes máscaras de código se usan para determinar qué niveles cumple el controlador:<br/>SQL_SCC_XOPEN_CLI_VERSION1: el controlador cumple con la versión 1 de la CLI de grupo abierta.<br/>SQL_SCC_ISO92_CLI: el controlador es compatible con la CLI ISO 92.|
|SQL_STATIC_CURSOR_ATTRIBUTES1|3.0|Máscara de SQLUINTEGER que incluya que describe los atributos de un cursor estático que son compatibles con el controlador. Esta máscara de subred contiene el primer subconjunto de atributos; para el segundo subconjunto, consulte SQL_STATIC_CURSOR_ATTRIBUTES2.<br/><br/>Las siguientes máscaras de código se usan para determinar los atributos que se admiten:<br/>SQL_CA1_NEXT<br/>SQL_CA1_ABSOLUTE<br/>SQL_CA1_RELATIVE<br/>SQL_CA1_BOOKMARK<br/>SQL_CA1_LOCK_NO_CHANGE<br/>SQL_CA1_LOCK_EXCLUSIVE<br/>SQL_CA1_LOCK_UNLOCK<br/>SQL_CA1_POS_POSITION<br/>SQL_CA1_POS_UPDATE<br/>SQL_CA1_POS_DELETE<br/>SQL_CA1_POS_REFRESH<br/>SQL_CA1_POSITIONED_UPDATE<br/>SQL_CA1_POSITIONED_DELETE<br/>SQL_CA1_SELECT_FOR_UPDATE<br/>SQL_CA1_BULK_ADD<br/>SQL_CA1_BULK_UPDATE_BY_BOOKMARK<br/>SQL_CA1_BULK_DELETE_BY_BOOKMARK<br/>SQL_CA1_BULK_FETCH_BY_BOOKMARK<br/><br/>Para obtener descripciones de estas máscaras de máscara, vea SQL_DYNAMIC_CURSOR_ATTRIBUTES1 (y sustituir "cursor estático" por "cursor dinámico" en las descripciones).<br/><br/>Normalmente, un controlador compatible con el nivel intermedio de SQL-92 devolverá las opciones SQL_CA1_NEXT, SQL_CA1_ABSOLUTE y SQL_CA1_RELATIVE tal como se admiten, ya que el controlador admite cursores desplazables a través de la instrucción SQL FETCH incrustada. Como esto no determina directamente la compatibilidad con SQL subyacente, no obstante, es posible que no se admitan los cursores desplazables, incluso para un controlador compatible con el nivel intermedio de SQL-92.|
|SQL_STATIC_CURSOR_ATTRIBUTES2|3.0|Máscara de SQLUINTEGER que incluya que describe los atributos de un cursor estático que son compatibles con el controlador. Esta máscara de subred contiene el segundo subconjunto de atributos; para el primer subconjunto, consulte SQL_STATIC_CURSOR_ATTRIBUTES1.<br/><br/>Las siguientes máscaras de código se usan para determinar los atributos que se admiten:<br/>SQL_CA2_READ_ONLY_CONCURRENCY<br/>SQL_CA2_LOCK_CONCURRENCY<br/>SQL_CA2_OPT_ROWVER_CONCURRENCY<br/>SQL_CA2_OPT_VALUES_CONCURRENCY<br/>SQL_CA2_SENSITIVITY_ADDITIONS<br/>SQL_CA2_SENSITIVITY_DELETIONS<br/>SQL_CA2_SENSITIVITY_UPDATES<br/>SQL_CA2_MAX_ROWS_SELECT<br/>SQL_CA2_MAX_ROWS_INSERT<br/>SQL_CA2_MAX_ROWS_DELETE<br/>SQL_CA2_MAX_ROWS_UPDATE<br/>SQL_CA2_MAX_ROWS_CATALOG<br/>SQL_CA2_MAX_ROWS_AFFECTS_ALL<br/>SQL_CA2_CRC_EXACT<br/>SQL_CA2_CRC_APPROXIMATE<br/>SQL_CA2_SIMULATE_NON_UNIQUE<br/>SQL_CA2_SIMULATE_TRY_UNIQUE<br/>SQL_CA2_SIMULATE_UNIQUE<br/><br/>Para obtener descripciones de estas máscaras de máscara, vea SQL_DYNAMIC_CURSOR_ATTRIBUTES2 (y sustituir "cursor estático" por "cursor dinámico" en las descripciones).|
|SQL_STRING_FUNCTIONS|1.0|Nota: el tipo de información se incorporó en ODBC 1,0; cada máscara de máscara tiene la etiqueta de la versión en la que se presentó.<br/><br/>Una máscara de SQLUINTEGER que incluya que enumera las funciones de cadena escalar admitidas por el controlador y el origen de datos asociado.<br/><br/>Las siguientes máscaras de código se usan para determinar qué funciones de cadena se admiten:<br/>SQL_FN_STR_ASCII (ODBC 1,0)<br/>SQL_FN_STR_BIT_LENGTH (ODBC 3,0)<br/>SQL_FN_STR_CHAR (ODBC 1,0)<br/>SQL_FN_STR_CHAR_LENGTH (ODBC 3,0)<br/>SQL_FN_STR_CHARACTER_LENGTH (ODBC 3,0)<br/>SQL_FN_STR_CONCAT (ODBC 1,0)<br/>SQL_FN_STR_DIFFERENCE (ODBC 2,0)<br/>SQL_FN_STR_INSERT (ODBC 1,0)<br/>SQL_FN_STR_LCASE (ODBC 1,0)<br/>SQL_FN_STR_LEFT (ODBC 1,0)<br/>SQL_FN_STR_LENGTH (ODBC 1,0)<br/>SQL_FN_STR_LOCATE (ODBC 1,0)<br/>SQL_FN_STR_LTRIM (ODBC 1,0)<br/>SQL_FN_STR_OCTET_LENGTH (ODBC 3,0)<br/>SQL_FN_STR_POSITION (ODBC 3,0)<br/>SQL_FN_STR_REPEAT (ODBC 1,0)<br/>SQL_FN_STR_REPLACE (ODBC 1,0)<br/>SQL_FN_STR_RIGHT (ODBC 1,0)<br/>SQL_FN_STR_RTRIM (ODBC 1,0)<br/>SQL_FN_STR_SOUNDEX (ODBC 2,0)<br/>SQL_FN_STR_SPACE (ODBC 2,0)<br/>SQL_FN_STR_SUBSTRING (ODBC 1,0)<br/>SQL_FN_STR_UCASE (ODBC 1,0)<br/><br/>Si una aplicación puede llamar a la función escalar **localizada** con los argumentos *string_exp1*, *string_exp2* y *Start* , el controlador devuelve la máscara de SQL_FN_STR_LOCATE. Si una aplicación puede llamar a la función escalar LOCATE solo con los argumentos *string_exp1* y *string_exp2* , el controlador devuelve la máscara de SQL_FN_STR_LOCATE_2. Los controladores que son totalmente compatibles con la función escalar de **búsqueda** devuelven ambas máscaras de.<br/><br/>(Para obtener más información, vea [funciones de cadena](../appendixes/string-functions.md) en el Apéndice E, "funciones escalares".)|
|SQL_SUBQUERIES|2.0|Una máscara de SQLUINTEGER que incluya que enumera los predicados que admiten subconsultas:<br/>SQL_SQ_CORRELATED_SUBQUERIES<br/>SQL_SQ_COMPARISON<br/>SQL_SQ_EXISTS<br/>SQL_SQ_INSQL_SQ_QUANTIFIED<br/><br/>La máscara de máscara SQL_SQ_CORRELATED_SUBQUERIES indica que todos los predicados que admiten subconsultas admiten subconsultas correlacionadas.<br/><br/>Un controlador compatible con el nivel de entrada SQL-92 siempre devolverá una máscara de bits en la que se establecen todos estos bits.|
|SQL_SYSTEM_FUNCTIONS|1.0|Una máscara de SQLUINTEGER que incluya que enumera las funciones del sistema escalares admitidas por el controlador y el origen de datos asociado.<br/><br/>Las siguientes máscaras de código se usan para determinar qué funciones del sistema se admiten:<br/>SQL_FN_SYS_DBNAME<br/>SQL_FN_SYS_IFNULL<br/>SQL_FN_SYS_USERNAME|
|SQL_TABLE_TERM|1.0|Cadena de caracteres con el nombre del proveedor del origen de datos para una tabla; por ejemplo, "Table" o "File".<br/><br/>Esta cadena de caracteres puede estar en mayúsculas, minúsculas o mezcladas.<br/><br/>Un controlador compatible con el nivel de entrada SQL-92 siempre devolverá "Table".|
|SQL_TIMEDATE_ADD_INTERVALS|2.0|Una máscara de SQLUINTEGER que incluya que enumera los intervalos de marca de tiempo admitidos por el controlador y el origen de datos asociado para la función escalar TIMESTAMPADD.<br/><br/>Las siguientes máscaras de código se usan para determinar los intervalos que se admiten:<br/>SQL_FN_TSI_FRAC_SECOND<br/>SQL_FN_TSI_SECOND<br/>SQL_FN_TSI_MINUTE<br/>SQL_FN_TSI_HOUR<br/>SQL_FN_TSI_DAY<br/>SQL_FN_TSI_WEEK<br/>SQL_FN_TSI_MONTH<br/>SQL_FN_TSI_QUARTER<br/>SQL_FN_TSI_YEAR<br/><br/>Un controlador compatible con el nivel de transición FIPS siempre devolverá una máscara de bits en la que se establecen todos estos bits.|
|SQL_TIMEDATE_DIFF_INTERVALS|2.0|Una máscara de SQLUINTEGER que incluya que enumera los intervalos de marca de tiempo admitidos por el controlador y el origen de datos asociado para la función escalar TIMESTAMPDIFF.<br/><br/>Las siguientes máscaras de código se usan para determinar los intervalos que se admiten:<br/>SQL_FN_TSI_FRAC_SECOND<br/>SQL_FN_TSI_SECOND<br/>SQL_FN_TSI_MINUTE<br/>SQL_FN_TSI_HOUR<br/>SQL_FN_TSI_DAY<br/>SQL_FN_TSI_WEEK<br/>SQL_FN_TSI_MONTH<br/>SQL_FN_TSI_QUARTER<br/>SQL_FN_TSI_YEAR<br/><br/>Un controlador compatible con el nivel de transición FIPS siempre devolverá una máscara de bits en la que se establecen todos estos bits.|
|SQL_TIMEDATE_FUNCTIONS|1.0|Nota: el tipo de información se incorporó en ODBC 1,0; cada máscara de máscara tiene la etiqueta de la versión en la que se presentó.<br/><br/>Una máscara de SQLUINTEGER que incluya que enumera las funciones escalares de fecha y hora que admiten el controlador y el origen de datos asociado.<br/><br/>Las siguientes máscaras de código se usan para determinar qué funciones de fecha y hora se admiten:<br/>SQL_FN_TD_CURRENT_DATE (ODBC 3,0)<br/>SQL_FN_TD_CURRENT_TIME (ODBC 3,0)<br/>SQL_FN_TD_CURRENT_TIMESTAMP (ODBC 3,0)<br/>SQL_FN_TD_CURDATE (ODBC 1,0)<br/>SQL_FN_TD_CURTIME (ODBC 1,0)<br/>SQL_FN_TD_DAYNAME (ODBC 2,0)<br/>SQL_FN_TD_DAYOFMONTH (ODBC 1,0)<br/>SQL_FN_TD_DAYOFWEEK (ODBC 1,0)<br/>SQL_FN_TD_DAYOFYEAR (ODBC 1,0)<br/>SQL_FN_TD_EXTRACT (ODBC 3,0)<br/>SQL_FN_TD_HOUR (ODBC 1,0)<br/>SQL_FN_TD_MINUTE (ODBC 1,0)<br/>SQL_FN_TD_MONTH (ODBC 1,0)<br/>SQL_FN_TD_MONTHNAME (ODBC 2,0)<br/>SQL_FN_TD_NOW (ODBC 1,0)<br/>SQL_FN_TD_QUARTER (ODBC 1,0)<br/>SQL_FN_TD_SECOND (ODBC 1,0)<br/>SQL_FN_TD_TIMESTAMPADD (ODBC 2,0)<br/>SQL_FN_TD_TIMESTAMPDIFF (ODBC 2,0)<br/>SQL_FN_TD_WEEK (ODBC 1,0)<br/>SQL_FN_TD_YEAR (ODBC 1,0)|
|SQL_TXN_CAPABLE|1.0|Nota: el tipo de información se incorporó en ODBC 1,0; cada valor devuelto se etiqueta con la versión en la que se presentó.<br/><br/>Un valor SQLUSMALLINT que describe la compatibilidad con transacciones en el controlador o el origen de datos:<br/>SQL_TC_NONE = no se admiten las transacciones. (ODBC 1,0)<br/>SQL_TC_DML = las transacciones solo pueden contener instrucciones del lenguaje de manipulación de datos (DML) (**Select**, **Insert**, **Update** y **Delete**). Las instrucciones del lenguaje de definición de datos (DDL) encontradas en una transacción producen un error. (ODBC 1,0)<br/>SQL_TC_DDL_COMMIT = las transacciones solo pueden contener instrucciones DML. Las instrucciones DDL (**CREATE TABLE**, **Drop index**, etc.) que se encuentran en una transacción provocan la confirmación de la transacción. (ODBC 2,0)<br/>SQL_TC_DDL_IGNORE = las transacciones solo pueden contener instrucciones DML. Se omiten las instrucciones DDL encontradas en una transacción. (ODBC 2,0)<br/>SQL_TC_ALL = las transacciones pueden contener instrucciones de DDL e instrucciones DML en cualquier orden. (ODBC 1,0)<br/><br/>(Dado que la compatibilidad de transacciones es obligatoria en SQL-92, un controlador compatible con SQL-92 [cualquier nivel] nunca devolverá SQL_TC_NONE).|
|SQL_TXN_ISOLATION_OPTION|1.0|Una máscara de SQLUINTEGER que incluya que enumera los niveles de aislamiento de transacción disponibles en el controlador o el origen de datos.<br/><br/>Las siguientes máscaras de código se usan junto con la marca para determinar qué opciones se admiten:<br/>SQL_TXN_READ_UNCOMMITTED<br/>SQL_TXN_READ_COMMITTED<br/>SQL_TXN_REPEATABLE_READ<br/>SQL_TXN_SERIALIZABLE<br/><br/>Para obtener descripciones de estos niveles de aislamiento, vea la descripción de SQL_DEFAULT_TXN_ISOLATION.<br/><br/>Para establecer el nivel de aislamiento de transacción, una aplicación llama a **SQLSetConnectAttr** para establecer el atributo de SQL_ATTR_TXN_ISOLATION. Para obtener más información, consulte [SQLSetConnectAttr (función](sqlsetconnectattr-function.md)).<br/><br/>Un controlador compatible con el nivel de entrada SQL-92 siempre devolverá SQL_TXN_SERIALIZABLE tal como se admite. Un controlador compatible con el nivel de transición FIPS siempre devolverá todas las opciones que se admiten.|
|SQL_UNION|2.0|Una máscara de SQLUINTEGER que incluya que enumera la compatibilidad con la cláusula **Union** :<br/>SQL_U_UNION = el origen de datos admite la cláusula **Union** .<br/>SQL_U_UNION_ALL = el origen de datos admite la palabra clave **All** en la cláusula **Union** . (**SQLGetInfo** devuelve SQL_U_UNION y SQL_U_UNION_ALL en este caso).<br/><br/>Un controlador compatible con el nivel de entrada SQL-92 siempre devolverá las dos opciones que se admiten.|
|SQL_USER_NAME|1.0|Cadena de caracteres con el nombre utilizado en una base de datos determinada, que puede ser diferente del nombre de inicio de sesión.|
|SQL_XOPEN_CLI_YEAR|3.0|Cadena de caracteres que indica el año de publicación de la especificación de grupo abierta con la que la versión del administrador de controladores ODBC es totalmente compatible.|
  
## <a name="example"></a>Ejemplo  

 **SQLGetInfo** devuelve listas de opciones admitidas como máscara de sqluinteger que incluya en **InfoValuePtr*. La máscara de la opción se usa junto con la marca para determinar si se admite la opción.  
  
 Por ejemplo, una aplicación podría usar el siguiente código para determinar si el controlador asociado a la conexión es compatible con la función escalar de subcadena.  
  
 Para obtener otro ejemplo del uso de **SQLGetInfo**, vea [SQLTables (función](sqltables-function.md)).  
  
```cpp  
SQLUINTEGER fFuncs;  
  
SQLGetInfo(hdbc,  
           SQL_STRING_FUNCTIONS,  
           (SQLPOINTER)&fFuncs,  
           sizeof(fFuncs),  
           NULL);  
  
// SUBSTRING supported  
if (fFuncs & SQL_FN_STR_SUBSTRING)  
   ;   // do something  
  
// SUBSTRING not supported  
else  
   ;   // do something else  
```  
  
## <a name="related-functions"></a>Funciones relacionadas  

 Devolver el valor de un atributo de conexión  
 [Función SQLGetConnectAttr](sqlgetconnectattr-function.md)  
  
 Determinar si un controlador admite una función  
 [Función SQLGetFunctions](sqlgetfunctions-function.md)  
  
 Devolver el valor de un atributo de instrucción  
 [Función SQLGetStmtAttr](sqlgetstmtattr-function.md)  
  
 Devolver información sobre los tipos de datos de un origen de datos  
 [Función SQLGetTypeInfo](sqlgettypeinfo-function.md)  
  
## <a name="see-also"></a>Consulte también  

 [Referencia de API ODBC](odbc-api-reference.md)  
 [Archivos de encabezado de ODBC](../install/odbc-header-files.md)
