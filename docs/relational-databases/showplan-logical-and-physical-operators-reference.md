---
description: Referencia de operadores lógicos y físicos del plan de presentación
title: Referencia de operadores lógicos y físicos del plan de presentación
ms.custom: seo-dt-2019
ms.date: 10/12/2017
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
f1_keywords:
- sql13.swb.showplan.leftouterjoin.f1
- sql13.swb.showplan.remotedelete.f1
- sql13.swb.showplan.parallelism.f1
- sql13.swb.showplan.indexspool.f1
- sql13.swb.showplan.result.f1
- sql13.swb.showplan.bitmapcreate.f1
- sql13.swb.showplan.remotescan.f1
- sql13.swb.showplan.union.f1
- sql13.swb.showplan.bitmap.f1
- sql13.swb.showplan.RIDLookup
- sql13.swb.showplan.innerjoin.f1
- sql13.swb.showplan.dynamic.f1
- sql13.swb.showplan.distributestreams.f1
- sql13.swb.showplan.clusteredindexdelete.f1
- sql13.swb.showplan.keylookup.f1
- sql13.swb.showplan.partialaggregate.f1
- sql13.swb.showplan.distinctsort.f1
- sql13.swb.showplan.collapse.f1
- sql13.swb.showplan.print.f1
- sql13.swb.showplan.crossjoin.f1
- sql13.swb.showplan.convert.f1
- sql13.swb.showplan.split.f1
- sql13.swb.showplan.top.f1
- sql13.swb.showplan.update.f1
- sql13.swb.showplan.keyset.f1
- sql13.swb.showplan.fetchquery.f1
- sql13.swb.showplan.mergejoin.f1
- sql13.swb.showplan.branchrepartition.f1
- sql13.swb.showplan.tableinsert.f1
- sql13.swb.showplan.clusteredindexseek.f1
- sql13.swb.showplan.indexupdate.f1
- sql13.swb.showplan.indexinsert.f1
- sql13.swb.showplan.clusteredindexupdate.f1
- sql13.swb.showplan.streamaggregate.f1
- sql13.swb.showplan.columnstoreindexdelete.f1
- sql13.swb.showplan.snapshot.f1
- sql13.swb.showplan.remotequery.f1
- sql13.swb.showplan.constantscan.f1
- sql13.swb.showplan.rank.f1
- sql13.swb.showplan.rightsemijoin.f1
- sql13.swb.showplan.delete.f1
- sql13.swb.showplan.sequence.f1
- sql13.swb.showplan.locate.f1
- sql13.swb.showplan.aggregate.f1
- sql13.swb.showplan.rightouterjoin.f1
- sql13.swb.showplan.columnstoreindexupdate.f1
- sql13.swb.showplan.clusteredindexinsert.f1
- sql13.swb.showplan.rowcountspool.f1
- sql13.swb.showplan.columnstoreindexscan.f1
- sql13.swb.showplan.leftantisemijoin.f1
- sql13.swb.showplan.sort.f1
- sql13.swb.showplan.leftsemijoin.f1
- sql13.swb.showplan.columnstoreindexinsert.f1
- sql13.swb.showplan.indexscan.f1
- sql13.swb.showplan.columnstoreindexmerge.f1
- sql13.swb.showplan.lazyspool.f1
- sql13.swb.showplan.rightantisemijoin.f1
- sql13.swb.showplan.bookmarklookup.f1
- sql13.swb.showplan.remoteinsert.f1
- sql13.swb.showplan.intrinsic.f1
- sql13.swb.showplan.arithmeticexpression.f1
- sql13.swb.showplan.populationquery.f1
- sql13.swb.showplan.filter.f1
- sql13.swb.showplan.if.f1
- sql13.swb.showplan.hashmatchteam.f1
- sql13.swb.showplan.tablevaluedfunction.f1
- sql13.swb.showplan.assign.f1
- sql13.swb.showplan.nestedloops.f1
- sql13.swb.showplan.buildhash.f1
- sql13.swb.showplan.mergeinterval.f1
- sql13.swb.showplan.hashmatch.f1
- sql13.swb.showplan.parametertablescan.f1
- sql13.swb.showplan.tablemerge.f1
- sql13.swb.showplan.switch.f1
- sql13.swb.showplan.sql.f1
- sql13.swb.showplan.repartitionstreams.f1
- sql13.swb.showplan.logrowscan.f1
- sql13.swb.showplan.assert.f1
- sql13.swb.showplan.computescalar.f1
- sql13.swb.showplan.broadcast.f1
- sql13.swb.showplan.indexseek.f1
- sql13.swb.showplan.gatherstreams.f1
- sql13.swb.showplan.remoteindexscan.f1
- sql13.swb.showplan.segment.f1
- sql13.swb.showplan.tableupdate.f1
- sql13.swb.showplan.clusteredindexscan.f1
- sql13.swb.showplan.cache.f1
- sql13.swb.showplan.spool.f1
- sql13.swb.showplan.indexdelete.f1
- sql13.swb.showplan.distinct.f1
- sql13.swb.showplan.deletedscan.f1
- sql13.swb.showplan.eagerspool.f1
- sql13.swb.showplan.hashmatchroot.f1
- sql13.swb.showplan.setfunction.f1
- sql13.swb.showplan.clusteredindexmerge.f1
- sql13.swb.showplan.flowdistinct.f1
- sql13.swb.showplan.tabledelete.f1
- sql13.swb.showplan.tablescan.f1
- sql13.swb.showplan.refreshquery.f1
- sql13.swb.showplan.tablespool.f1
- sql13.swb.showplan.insertedscan.f1
- sql13.swb.showplan.insert.f1
- sql13.swb.showplan.remoteindexseek.f1
- sql13.swb.showplan.fullouterjoin.f1
- sql13.swb.showplan.declare.f1
- sql13.swb.showplan.udx.f1
- sql13.swb.showplan.while.f1
- sql13.swb.showplan.remoteupdate.f1
- sql13.swb.showplan.concatenation.f1
- sql13.swb.showplan.computescalar
- sql13.swb.showplan.foreignkeyreferencescheck
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
author: rothja
ms.author: jroth
monikerRange: =azuresqldb-current||>=sql-server-2016||>=sql-server-linux-2017||=azuresqldb-mi-current
ms.openlocfilehash: 7d5ef357580cf28d4173ebd945e5f683d2fd1911
ms.sourcegitcommit: 1a544cf4dd2720b124c3697d1e62ae7741db757c
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 12/14/2020
ms.locfileid: "97473256"
---
# <a name="showplan-logical-and-physical-operators-reference"></a>Referencia de operadores lógicos y físicos del plan de presentación
[!INCLUDE [SQL Server Azure SQL Database](../includes/applies-to-version/sql-asdb.md)]
  Los operadores describen cómo [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] ejecuta una consulta o una instrucción DML (Lenguaje de manipulación de datos). El optimizador de consultas usa operadores para generar un plan de consulta con el fin de crear el resultado especificado en la consulta o para realizar la operación especificada en la instrucción DML. El plan de consulta es un árbol que consta de operadores físicos. Puede ver el plan de consulta mediante las instrucciones SET SHOWPLAN, las opciones gráficas del plan de ejecución de [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]o las clases de eventos Showplan de SQL Server Profiler.  
  
 Los operadores se clasifican como lógicos y físicos.  
  
 **Operadores lógicos**  
 Los operadores lógicos describen la operación algebraica relacional usada para procesar una instrucción. En otras palabras, los operadores lógicos describen conceptualmente la operación que se debe realizar.  
  
 **Operadores físicos**  
 Los operadores físicos implementan la operación descrita por los operadores lógicos. Cada operador físico es un objeto o rutina que realiza una operación. Por ejemplo, algunos operadores físicos obtienen acceso a columnas o filas desde una tabla, índice o vista. Otros operadores físicos realizan otras operaciones como cálculos, agregaciones, comprobaciones de integridad de datos o combinaciones. Los operadores físicos tienen costos asociados.  
  
 Los operadores físicos se inicializan, recopilan datos y se cierran. Específicamente, el operador físico puede responder a las llamadas de los tres métodos siguientes:  
  
-   **Init()** : el método **Init()** hace que un operador físico se inicialice y configure las estructuras de datos necesarias. El operador físico puede recibir numerosas llamadas **Init()** , aunque suele recibir solo una.  
  
-   **GetNext()** : el método **GetNext()** hace que un operador físico obtenga la primera fila de datos o la siguiente. El operador físico puede recibir ninguna o numerosas llamadas **GetNext()** .  
  
-   **Close()** : el método **Close()** hace que un operador físico realice algunas operaciones de limpieza y se cierre. Un operador físico recibe únicamente una llamada de **Close()** .  
  
El método **GetNext()** devuelve una fila de datos, mientras que el número de veces que se llama aparece como **ActualRows** en los resultados del plan de presentación generado mediante `SET STATISTICS PROFILE ON` o `SET STATISTICS XML ON`. Para obtener más información sobre estas opciones de SET, vea [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](../t-sql/statements/set-statistics-profile-transact-sql.md) y [SET STATISTICS XML &#40;Transact-SQL&#41;](../t-sql/statements/set-statistics-xml-transact-sql.md).  
  
Los recuentos **ActualRebinds** y **ActualRewinds** que aparecen en los resultados del plan de presentación hacen referencia al número de veces que se llama al método **Init()** . A menos que haya un operador en la parte interna de una combinación de bucles anidados, **ActualRebinds** es igual a uno y **ActualRewinds** es igual a cero. Si hay un operador en la parte interna de una combinación de bucles, la suma del número de reenlaces y rebobinados es igual al número de filas procesadas en la parte externa de la combinación. Un reenlace significa que uno o más de los parámetros correlativos de la combinación han cambiado y es necesario volver a evaluar la parte interna. Un rebobinado significa que ninguno de los parámetros correlativos ha cambiado y aún se puede volver a utilizar el conjunto de resultados interno anterior.  
  
**ActualRebinds** y **ActualRewinds** aparecen en los resultados del plan de presentación XML generado mediante SET STATISTICS XML ON. Solo se rellenan para los operadores **Nonclustered Index Spool**, **Remote Query**, **Row Count Spool**, **Sort**, **Table Spool** y **Table-valued Function** . **ActualRebinds** y **ActualRewinds** también se pueden rellenar para los operadores **Assert** y **Filter** cuando el atributo **StartupExpression** está establecido en TRUE.  
  
Cuando **ActualRebinds** y **ActualRewinds** aparecen en un plan de presentación XML, son comparables a **EstimateRebinds** y **EstimateRewinds**. Si no aparecen, el número estimado de filas (**EstimateRows**) es comparable al número real de filas (**ActualRows**). Tenga en cuenta que si no aparecen, los resultados reales del plan de presentación gráfico muestran ceros para los reenlaces y rebobinados reales.  
  
Hay un contador relacionado disponible, **ActualEndOfScans**, únicamente cuando se generan los resultados del plan de presentación mediante SET STATISTICS XML ON. Siempre que un operador físico alcanza el final de su flujo de datos, este contador se incrementa en uno. Un operador físico puede alcanzar el final de su flujo de datos cero, una o varias veces. Al igual que los reenlaces y rebobinados, el número de finales de recorrido puede ser superior a uno únicamente si el operador se encuentra en la parte interna de una combinación de bucles. El número de finales de recorrido debería ser inferior o igual a la suma del número de reenlaces y rebobinados.  
  
## <a name="mapping-physical-and-logical-operators"></a>Asignar operadores físicos y lógicos  
 El optimizador de consultas crea un plan de consulta con forma de árbol que consta de operadores lógicos. Una vez que el optimizador de consultas ha creado el plan, elige el operador físico más eficaz para cada operador lógico. El optimizador de consultas utiliza un método basado en el costo para determinar el operador físico que implementará un operador lógico.  
  
 Normalmente, varios operadores físicos pueden implementar una operación lógica. Sin embargo, en pocas ocasiones un operador físico puede implementar varias operaciones lógicas también.  
  
## <a name="operator-descriptions"></a>Descripción del operador  
 Esta sección contiene las descripciones de los operadores lógicos y físicos.  

 > [!TIP]
 > Siempre que un icono del plan de ejecución gráfico determinado tenga un círculo amarillo con dos flechas de derecha a izquierda, significa que el operador se ejecuta en paralelo. Para obtener más información sobre el paralelismo, vea la [Guía de arquitectura de subprocesos y tareas](../relational-databases/thread-and-task-architecture-guide.md#sql-server-task-scheduling).
  
|Icono del plan de ejecución gráfico|Operador de plan de presentación|Descripción|  
|-----------------------------------|-----------------------|-----------------|  
|![Icono del operador de combinación adaptable](../relational-databases/media/AdaptiveJoin.gif "Icono del operador de combinación adaptable")|**Combinación adaptable**|El operador **Combinación adaptable** permite retrasar un método de combinación hash o de combinación de bucles anidados hasta después de que se haya examinado la primera entrada. El operador **Combinación adaptable** es un operador físico. Para obtener más información, vea [Descripción de las combinaciones adaptables](../relational-databases/performance/joins.md#adaptive). | 
|None|**Agregada**|El operador **Aggregate** calcula una expresión que contiene MIN, MAX, SUM, COUNT o AVG. El operador **Aggregate** puede ser un operador lógico o físico.| 
|![Icono del operador de expresión aritmética](../relational-databases/media/arithmetic-expression-32x-2.gif "Icono del operador de expresión aritmética")|**Arithmetic Expression**|El operador **Arithmetic Expression** calcula un nuevo valor a partir de los valores de una fila. **Arithmetic Expression** no se usa en [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].| 
|None|**Async Concat**|El operador **Async Concat** solo se usa en consultas remotas (consultas distribuidas). Tiene *n* nodos secundarios y un nodo primario. Algunos de los nodos secundarios suelen ser equipos remotos que participan en una consulta distribuida. **Async Concat** emite llamadas `open()` a todos los nodos secundarios a la vez y, después, asigna un mapa de bits a cada uno de estos nodos. Por cada bit que sea un 1, **Async Concat** envía las filas de salida a petición al nodo primario.| 
|![Icono del operador Assert](../relational-databases/media/assert-32x.gif "Icono del operador Assert")|**Assert**|El operador **Assert** comprueba una condición. Por ejemplo, valida la integridad referencial o se asegura de que una subconsulta escalar devuelve una fila. Por cada fila de entrada, el operador **Assert** evalúa la expresión de la columna **Argument** del plan de ejecución. Si la expresión da como resultado NULL, la fila se pasa a través del operador **Assert** y continúa la ejecución de la consulta. Si la expresión da como resultado un valor distinto a NULL, se generará el error apropiado. **Assert** es un operador físico.| 
|![Icono del elemento del lenguaje Assign](../relational-databases/media/assign-32.gif "Icono del elemento del lenguaje Assign")|**Assign**|El operador **Assign** asigna el valor de una expresión o una constante a una variable. **Assign** es un elemento del lenguaje.| 
|![Icono del operador Bitmap](../relational-databases/media/bitmap-32x.gif "Icono del operador Bitmap")|**Bitmap Create**|El operador **Bitmap Create** aparece en el resultado del plan de presentación en la que se generan los mapas de bits. **Bitmap Create** es un operador lógico.| 
|![Icono del operador Bitmap](../relational-databases/media/bitmap-32x.gif "Icono del operador Bitmap")|**Bitmap**|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] usa el operador **Bitmap** para implementar filtros de mapas de bits en planes de consulta paralelos. Los filtros de mapas de bits agiliza la ejecución de la consulta al eliminar las filas con valores de clave que no pueden generar ningún registro de combinación antes de pasar las filas a través de otro operador, por ejemplo, el operador **Parallelism** . Un filtro de mapas de bits usa una representación compacta de un conjunto de valores de una tabla en una parte del árbol de operadores para filtrar filas de una segunda tabla en otra parte del árbol. Si se quitan las filas innecesarias de la consulta en una fase temprana, los operadores subsiguientes tienen menos filas con las que trabajar y el rendimiento global de la consulta mejora. El optimizador determina cuando un mapa de bits es suficientemente selectivo para resultar útil y en qué operadores se aplica el filtro. **Bitmap** es un operador físico.| 
|![Icono del operador Bookmark Lookup](../relational-databases/media/bookmark-lookup-32x.gif "Icono del operador Bookmark Lookup")|**Bookmark Lookup**|El operador **Bookmark Lookup** usa un marcador (identificador de fila o clave de agrupación en clústeres) para buscar la fila correspondiente en la tabla o índice agrupado. La columna **Argument** contiene la etiqueta del marcador utilizado para buscar la fila en la tabla o el índice clúster. La columna **Argument** también contiene el nombre de la tabla o el índice clúster donde se busca la fila. Si la columna **Argument** refleja la cláusula WITH PREFETCH, el procesador de consultas habrá determinado que resulta óptimo usar una captura previa asincrónica (lectura anticipada) al buscar marcadores en la tabla o el índice agrupado.<br /><br /> A partir de [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)], no se usa **Bookmark Lookup**. En su lugar, **Key Lookup** y **RID Lookup** proporcionan la funcionalidad de búsqueda de marcadores.| 
|None|**Branch Repartition**|En un plan de consulta paralelo, a veces hay regiones conceptuales de iteradores. Todos los iteradores de una región así se pueden ejecutar mediante subprocesos paralelos. Las regiones en sí deben ejecutarse en serie. Algunos de los iteradores **Parallelism** de una región individual se denominan **Branch Repartition**. El iterador **Parallelism** situado en el límite de dos de estas regiones se denomina **Segment Repartition**. **Branch Repartition** y **Segment Repartition** son operadores lógicos.| 
|None|**Broadcast**|**Broadcast** tiene un nodo secundario y *n* nodos primarios. **Broadcast** envía las filas de entrada a varios consumidores a petición. Cada consumidor recibe todas las filas. Por ejemplo, si todos los consumidores son lados de creación de una combinación hash, se crearán *n* copias de las tablas hash.| 
|![Icono del operador Build Hash](../relational-databases/media/build-hash.gif "Icono del operador Build Hash")|**Build Hash**|Indica la compilación de una tabla hash del lote para un índice optimizado memoria de columnstore de xVelocity.| 
|None|**Memoria caché**|**Cache** es una versión especializada del operador **Spool** . Almacena solo una fila de datos. **Cache** es un operador lógico. **Cache** no se usa en [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].| 
|![Icono del operador Clustered Index Delete](../relational-databases/media/clustered-index-delete-32x.gif "Icono del operador Clustered Index Delete")|**Clustered Index Delete**|El operador **Clustered Index Delete** elimina filas del índice agrupado especificado en la columna Argument del plan de ejecución de consulta. Si hay un predicado WHERE:() en la columna Argument, solo se eliminan las filas que cumplen el predicado.**Clustered Index Delete** es un operador físico.| 
|![Icono del operador Clustered Index Insert](../relational-databases/media/clustered-index-insert-32x.gif "Icono del operador Clustered Index Insert")|**Clustered Index Insert**|El operador del plan de presentación **Clustered Index Insert** inserta filas desde su entrada en el índice agrupado especificado en la columna Argument. La columna Argument también contiene un predicado SET:(), que indica el valor en el que se establece cada columna. Si **Clustered Index Insert** no tiene elementos secundarios para los valores de inserción, se obtendrá la fila insertada del operador **Insert** .**Clustered Index Insert** es un operador físico.| 
|![Operador Clustered Index Merge](../relational-databases/media/clustered-index-merge-32x.gif "Operador Clustered Index Merge")|**Clustered Index Merge**|El operador **Clustered Index Merge** aplica un flujo de datos de mezcla a un índice clúster. El operador elimina, actualiza o inserta filas del índice clúster especificado en la columna **Argumento** del operador. La operación real ejecutada depende del valor de tiempo de ejecución de la columna **ACCIÓN** especificada en la columna **Argument** del operador. **Clustered Index Merge** es un operador físico.| 
|![Icono del operador Clustered Index Scan](../relational-databases/media/clustered-index-scan-32x.gif "Icono del operador Clustered Index Scan")|**Clustered Index Scan**|El operador **Clustered Index Scan** examina el índice agrupado especificado en la columna Argument del plan de ejecución de consulta. Si hay un predicado WHERE:() opcional, solo se devuelven las filas que lo cumplen. Si la columna Argument contiene la cláusula ORDERED, el procesador de consultas ha solicitado que la salida de las filas se devuelva en el orden en que las haya ordenado el índice clúster. Si no hay una cláusula ORDERED, el motor de almacenamiento recorre el índice de la forma óptima (sin tener que ordenar el resultado). **Clustered Index Scan** es un operador lógico y físico.| 
|![Icono del operador Clustered Index Seek](../relational-databases/media/clustered-index-seek-32x.gif "Icono del operador Clustered Index Seek")|**Clustered Index Seek**|El operador **Clustered Index Seek** usa la capacidad de búsqueda de los índices para recuperar filas de un índice clúster. La columna **Argument** contiene el nombre del índice agrupado que se va a usar y el predicado SEEK:(). El motor de almacenamiento utiliza el índice para procesar solamente las filas que cumplen el predicado SEEK:(). También puede incluir un predicado WHERE:() en el que el motor de almacenamiento determine todas las filas que cumplan el predicado SEEK:(), aunque este predicado es opcional y no utiliza índices para completar el proceso.<br /><br /> Si la columna **Argument** contiene la cláusula ORDERED, significa que el procesador de consultas ha determinado que se deben devolver las filas en el orden en el que el índice clúster las haya clasificado. Si no hay una cláusula ORDERED, el motor de almacenamiento busca el índice de la forma óptima (sin tener que ordenar el resultado). Permitir que el resultado conserve su ordenación puede ser menos eficiente que generar un resultado no ordenado. Si aparece la palabra clave LOOKUP, significa que se está realizando una búsqueda de marcadores. En [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] y versiones posteriores, el operador **Key Lookup** proporciona la función de búsqueda de marcadores. **Clustered Index Seek** es un operador lógico y físico.| 
|![Icono del operador Clustered Index Update](../relational-databases/media/clustered-index-update-32x.gif "Icono del operador Clustered Index Update")|**Clustered Index Update**|El operador **Clustered Index Update** actualiza las filas de entrada del índice agrupado especificado en la columna **Argument** . Si hay un predicado WHERE:(), solo se actualizan las filas que cumplen el predicado. Si hay un predicado SET:(), se asigna este valor a todas las filas actualizadas. Si hay un predicado DEFINE:(), se muestran los valores que define este operador. Se puede hacer referencia a estos valores en la cláusula SET o en cualquier parte del operador, y en cualquier parte de esta consulta. **Clustered Index Update** es un operador lógico y físico.| 
|![Icono del operador Collapse](../relational-databases/media/collapse-32x.gif "Icono del operador Collapse")|**Contraer**|El operador **Collapse** optimiza el proceso de actualización. Cuando se realiza una actualización, esta se puede dividir (con el operador **Split** ) en una eliminación y una inserción. La columna **Argument** contiene una cláusula GROUP BY:() que especifica una lista de columnas de clave. Si el procesador de consultas encuentra filas adyacentes que eliminan e insertan los mismos valores clave, reemplazará estas operaciones independientes por una única operación de actualización más eficaz. **Collapse** es un operador lógico y físico.| 
|![Exploración de índice de almacén de columnas](../relational-databases/media/columnstoreindexscan.gif "Exploración de índice de almacén de columnas")|**Exploración de índice de almacén de columnas**|El operador **Columnstore Index Scan** recorre el índice columnstore especificado en la columna **Argument** del plan de ejecución de consulta.| 
|![Icono del operador Compute Scalar](../relational-databases/media/compute-scalar-32x.gif "Icono del operador Compute Scalar")|**Compute Scalar**|El operador **Compute Scalar** evalúa una expresión para generar un valor escalar calculado. que se puede devolver al usuario, hacer referencia a él en cualquier otra parte de la consulta, o ambas cosas a la vez, por ejemplo, en un predicado de filtro o de combinación. **Compute Scalar** es un operador lógico y físico.<br /><br /> Es posible que los operadores **Compute Scalar** que aparecen en planes de presentación generados por SET STATISTICS XML no contengan el elemento **RunTimeInformation** . En planes de presentación gráficos, es posible que las opciones **Número de filas real**, **Reenlaces reales** y **Rebobinados reales** no aparezcan en la ventana **Propiedades** cuando la opción **Incluir plan de ejecucion real** está seleccionada en [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]. Si esto ocurre, significa que, aunque estos operadores se han utilizado en el plan de consulta compilado, otros operadores han realizado su trabajo en el plan de consulta en tiempo de ejecución. Tenga en cuenta también que el número de ejecuciones en el resultado del plan de presentación generado por SET STATISTICS PROFILE es equivalente a la suma de reenlaces y rebobinados de planes de presentación generados por SET STATISTICS XML.| 
|![Icono del operador Concatenation](../relational-databases/media/concatenation-32x.gif "Icono del operador Concatenation")|**Concatenation**|El operador **Concatenation** explora varias entradas y devuelve cada fila explorada. Normalmente,**Concatenation** se utiliza para implementar la construcción UNION ALL de [!INCLUDE[tsql](../includes/tsql-md.md)] . El operador físico **Concatenation** tiene dos o más entradas y una salida. Concatenation copia filas del primer flujo de entrada en el flujo de salida y, a continuación, repite esta operación con cada flujo de entrada adicional. **Concatenation** es un operador lógico y físico.| 
|![Icono del operador Constant Scan](../relational-databases/media/constant-scan-32x.gif "Icono del operador Constant Scan")|**Constant Scan**|El operador **Constant Scan** escribe una o varias filas de constantes en una consulta. El operador **Compute Scalar** se suele usar después de **Constant Scan** para agregar columnas a una fila generada por el operador **Compute Scalar**.| 
|![Icono del elemento del lenguaje Convert (motor de base de datos)](../relational-databases/media/convert-32x.gif "Icono del elemento del lenguaje Convert (motor de base de datos)")|**Convertir**|El operador **Convert** convierte un tipo de datos escalar en otro. **Convert** es un elemento del lenguaje.| 
|None|**Cross Join**|El operador **Cross Join** combina cada fila de la primera entrada (superior) con cada fila de la segunda entrada (inferior). **Cross Join** es un operador lógico.| 
|None|**Cursor**|Los operadores lógicos y físicos **Cursor** se usan para describir cómo se ha ejecutado una consulta o una actualización que implican la ejecución de operaciones con cursores. Los operadores físicos describen el algoritmo físico de implementación utilizado para procesar el cursor, por ejemplo, con un cursor dinámico. Cada paso de la ejecución de un cursor implica un operador físico. Los operadores lógicos describen una propiedad del cursor, como, por ejemplo, si el cursor es de solo lectura.<br /><br /> Los operadores lógicos incluyen asincrónico, optimista, principal, solo lectura, bloqueos de desplazamiento, y secundario y sincrónico.<br /><br /> Los operadores físicos incluyen Dynamic, Fetch Query, Keyset, Population Query, Refresh Query y Snapshot.| 
|![Icono del operador de cursor de selección de cursor (catchall)](../relational-databases/media/cursor-catch-all.gif "Icono del operador de cursor de selección de cursor (catchall)")|**catchall**|El icono de selección (catchall) se muestra cuando la lógica que genera planes de presentación gráficos no puede encontrar un icono adecuado para el iterador. Este icono no indica necesariamente una condición de error. Hay tres iconos de selección (catchall): azul (para iteradores), naranja (para cursores) y verde (para elementos del lenguaje [!INCLUDE[tsql](../includes/tsql-md.md)] ).| 
|![Icono del elemento del lenguaje Declare](../relational-databases/media/declare-32x.gif "Icono del elemento del lenguaje Declare")|**Declare**|El operador **Declare** asigna una variable local en el plan de consulta. **Declare** es un elemento del lenguaje.| 
|![Icono del operador Delete (motor de base de datos)](../relational-databases/media/delete-32x.gif "Icono del operador Delete (motor de base de datos)")|**Eliminar**|El operador **Delete** elimina de un objeto las filas que satisfacen el predicado opcional de la columna **Argument** .| 
|![Icono del operador Delete Scan](../relational-databases/media/delete-scan-32x.gif "Icono del operador Delete Scan")|**Deleted Scan**|El operador **Deleted Scan** recorre la tabla eliminada en un desencadenador.| 
|None|**Distinct Sort**|El operador lógico **Distinct Sort** examina la entrada, quita los duplicados y ordena por las columnas especificadas en el predicado ORDER BY:() de la columna **Argument** . **Distinct Sort** es un operador lógico.| 
|None|**Distinct**|El operador **Distinct** quita los duplicados de un conjunto de filas o de una colección de valores. **Distinct** es un operador lógico.| 
|![Icono del operador de paralelismo Distribute Streams](../relational-databases/media/parallelism-distribute-stream.gif "Icono del operador de paralelismo Distribute Streams")|**Distribute Streams**|El operador **Distribute Streams** solo se usa en los planes de consulta paralelos. El operador **Distribute Streams** utiliza una solo flujo de entrada de registros y genera varios flujos de salida. No se cambia el contenido de los registros ni su formato. Cada registro del flujo de entrada aparece en uno de los flujos de salida. Este operador conserva automáticamente el orden relativo de los registros de entrada en los flujos de salida. Normalmente, se utilizan algoritmos hash para decidir a qué flujo de salida pertenece un determinado registro de entrada.<br /><br /> Si la salida tiene particiones, la columna **Argument** contiene un predicado PARTITION COLUMNS:() y las columnas de particiones. **Distribute Streams** es un operador lógico| 
|![Icono del operador de cursor Dynamic](../relational-databases/media/dynamic-32x.gif "Icono del operador de cursor Dynamic")|**Dinámica**|El operador **Dynamic** usa un cursor que puede ver todos los cambios que han realizado otros usuarios.| 
|![Icono del operador de cursor Fetch Query](../relational-databases/media/fetch-query-32x.gif "Icono del operador de cursor Fetch Query")|**Fetch Query**|El operador **Fetch Query** recupera filas cuando se emite una captura en un cursor.| 
|![Icono del operador Filter (motor de base de datos)](../relational-databases/media/filter-32x.gif "Icono del operador Filter (motor de base de datos)")|**Filter**|El operador **Filter** examina la entrada y solo devuelve las filas que cumplen la expresión del filtro (predicado) que aparece en la columna **Argument** .| 
|None|**Flow Distinct**|El operador lógico **Flow Distinct** recorre la entrada y quita los duplicados. Mientras que el operador **Distinct** procesa todas las entradas antes de obtener resultados, el operador **FlowDistinct** devuelve cada fila a medida que se obtiene de la entrada (a menos que la fila esté duplicada, en cuyo caso se descarta).| 
|![Icono del operador de comprobación de referencias de claves externas](../relational-databases/media/fk-references-32x.gif "Icono del operador de comprobación de referencias de claves externas")|**Comprobación de referencias de claves externas**|El operador **Comprobación de referencias de claves externas** realiza comprobaciones de integridad referencial locales, mediante la comparación de la fila modificada con las filas de las tablas de referencia para comprobar que la modificación no interrumpirá la integridad referencial. El operador **Comprobación de referencias de claves externas** se usa cuando existen más de 253 referencias de clave externa en la misma clave principal o única. **Comprobación de referencias de claves externas** es un operador lógico y físico.| 
|None|**Full Outer Join**|El operador lógico **Full Outer Join** devuelve cada fila que cumple el predicado de combinación de la primera entrada (superior) combinada con cada fila de la segunda entrada (inferior). También devuelve filas de:<br /><br /> -La primera entrada que no tenga coincidencias en la segunda entrada.<br /><br /> -La segunda entrada que no tenga coincidencias en la primera entrada.<br /><br /> La entrada que no contiene valores coincidentes se devuelve como un valor nulo. **Full Outer Join** es un operador lógico.| 
|![Icono del operador de paralelismo Gather Streams](../relational-databases/media/parallelism-32x.gif "Icono del operador de paralelismo Gather Streams")|**Gather Streams**|El operador **Gather Streams** solo se usa en planes de consulta paralelos. El operador **Gather Streams** procesa varios flujos de entrada y produce un único flujo de salida de registros combinando los flujos de entrada. No se cambia el contenido de los registros ni su formato. Si este operador conserva el orden, todos los flujos de entrada deben estar ordenados. Si se ordena la salida, la columna **Argument** contiene un predicado ORDER BY:() y los nombres de las columnas que se ordenan. **Gather Streams** es un operador lógico.| 
|![Icono del operador Hash Match](../relational-databases/media/hash-match-32x.gif "Icono del operador Hash Match")|**Hash Match**|El operador **Hash Match** genera una tabla hash y calcula un valor hash para cada fila de su entrada de compilación. En la columna **Argument** aparece un predicado HASH:() con una lista de las columnas usadas para crear un valor hash. A continuación, por cada fila de sondeo (como corresponda), calcula un valor hash (con la misma función hash) y busca las coincidencias en la tabla hash. Si hay un predicado residual (identificado mediante RESIDUAL:() en la columna **Argument** ), ese predicado también debe cumplirse para que una fila se considere una coincidencia. El comportamiento depende de la operación lógica que se esté realizando:<br /><br /> -Para cualquier combinación, utilice la primera entrada (superior) para generar la tabla hash y la segunda entrada (inferior) para sondear la tabla hash. Obtendrá como resultado las coincidencias (o las no coincidencias) que indique el tipo de combinación. Si varias combinaciones utilizan la misma columna de combinación, estas operaciones se agrupan en un equipo hash.<br /><br /> -Para los operadores Distinct o Aggregate, utilice la entrada para generar la tabla hash (para ello, quite los duplicados y calcule las expresiones de agregado). Cuando se haya generado la tabla hash, recorra la tabla y presente todas las entradas.<br /><br /> -En el caso del operador Union, utilice la primera entrada para generar la tabla hash (para ello, quite los duplicados). Use la segunda entrada (que no debe tener duplicados) para sondear la tabla hash, devolver todas las filas que no tengan coincidencias y, a continuación, recorrer la tabla hash para devolver todas las entradas.<br />**Hash Match** es un operador físico. Para obtener más información, vea [Descripción de las combinaciones hash](../relational-databases/performance/joins.md#hash).| 
|![Icono del elemento del lenguaje If](../relational-databases/media/if-32x.gif "Icono del elemento del lenguaje If")|**If**|El operador **If** lleva a cabo el procesamiento condicional basado en una expresión. **If** es un elemento del lenguaje.| 
|None|**Inner Join**|El operador lógico **Inner Join** devuelve todas las filas que cumplen la combinación de la primera entrada (superior) con la segunda entrada (inferior).| 
|![Icono del operador Insert (motor de base de datos)](../relational-databases/media/insert-32x.gif "Icono del operador Insert (motor de base de datos)")|**Insertar**|El operador lógico **Insert** inserta cada fila de su entrada en el objeto especificado en la columna **Argument** . El operador físico es **Table Insert**, **Index Insert** o **Clustered Index Insert**| 
|![Icono del operador Inserted Scan](../relational-databases/media/inserted-scan-32x.gif "Icono del operador Inserted Scan")|**Inserted Scan**|El operador **Inserted Scan** recorre la tabla **insertada** . **Inserted Scan** es un operador lógico y físico.| 
|![Icono del elemento del lenguaje Intrinsic](../relational-databases/media/intrinsic-32x.gif "Icono del elemento del lenguaje Intrinsic")|**Intrinsic**|El operador **Intrinsic** invoca una función [!INCLUDE[tsql](../includes/tsql-md.md)] interna. **Intrinsic** es un elemento del lenguaje.| 
|![Icono del operador de selección (catchall) de iterador](../relational-databases/media/iterator-catch-all.gif "Icono del operador de selección (catchall) de iterador")|**Iterator**|El icono de selección (catchall) **Iterator** se muestra cuando la lógica que genera planes de presentación gráficos no puede encontrar un icono adecuado para el iterador. Este icono no indica necesariamente una condición de error. Hay tres iconos de selección (catchall): azul (para iteradores), naranja (para cursores) y verde (para construcciones del lenguaje [!INCLUDE[tsql](../includes/tsql-md.md)] ).| 
|![Icono del operador Bookmark Lookup](../relational-databases/media/bookmark-lookup-32x.gif "Icono del operador Bookmark Lookup")|**Key Lookup**|El operador **Key Lookup** es una búsqueda de marcadores en un tabla con un índice clúster. La columna **Argument** contiene el nombre del índice clúster y la clave de agrupación en clústeres utilizada para buscar la fila en el índice clúster. **Key Lookup** está siempre acompañado por un operador **Nested Loops** . Si en la columna **Argument** aparece la cláusula WITH PREFETCH, el procesador de consultas habrá determinado que resulta óptimo usar una captura previa asincrónica (lectura anticipada) al buscar marcadores en el índice agrupado.<br /><br /> El uso de un operador **Key Lookup** en un plan de consulta indica que la consulta puede beneficiarse de la optimización del rendimiento. Por ejemplo, el rendimiento de las consultas se puede mejorar al agregar un índice de cobertura.| 
|![Icono del operador de cursor Keyset](../relational-databases/media/keyset-32x.gif "Icono del operador de cursor Keyset")|**Keyset**|El operador **Keyset** usa un cursor que puede ver las actualizaciones, pero no las inserciones que realizan los demás.| 
|![Icono de selección (catchall) de elementos de lenguaje](../relational-databases/media/language-construct-catch-all.gif "Icono de selección (catchall) de elementos de lenguaje")|**Elemento Language**|El icono de selección (catchall) **Language Element** se muestra cuando la lógica que genera planes de presentación gráficos no puede encontrar un icono adecuado para el iterador. Este icono no indica necesariamente una condición de error. Hay tres iconos de selección (catchall): azul (para iteradores), naranja (para cursores) y verde (para construcciones del lenguaje [!INCLUDE[tsql](../includes/tsql-md.md)] ).| 
|None|**Left Anti Semi Join**|El operador **Left Anti Semi Join** devuelve todas las filas de la primera entrada (superior) cuando no hay ninguna fila coincidente en la segunda entrada (inferior). Si no hay ningún predicado de combinación en la columna **Argument** , cada fila es una fila coincidente. **Left Anti Semi Join** es un operador lógico.| 
|None|**Left Outer Join**|El operador **Left Outer Join** devuelve cada fila que cumple la combinación de la primera entrada (superior) con la segunda entrada (inferior). También devuelve las filas de la primera entrada que no tienen filas coincidentes en la segunda entrada. Las filas que no coinciden en la segunda entrada se devuelven como valores NULL. Si no hay ningún predicado de combinación en la columna **Argument** , cada fila es una fila coincidente. **Left Outer Join** es un operador lógico.| 
|None|**Left Semi Join**|El operador **Left Semi Join** devuelve todas las filas de la primera entrada (superior) cuando hay una fila coincidente en la segunda entrada (inferior). Si no hay ningún predicado de combinación en la columna **Argument** , cada fila es una fila coincidente. **Left Semi Join** es un operador lógico.| 
|![Icono del operador Log Row Scan](../relational-databases/media/log-row-scan-32x.gif "Icono del operador Log Row Scan")|**Log Row Scan**|El operador **Log Row Scan** recorre el registro de transacciones. **Log Row Scan** es un operador lógico y físico.| 
|![Icono del operador Merge Interval](../relational-databases/media/merge-interval-32x.gif "Icono del operador Merge Interval")|**Merge Interval**|El operador **Merge Interval** combina varios intervalos (que pueden superponerse) para producir intervalos mínimos que no se superponen y que se usan para buscar entradas de índice. Este operador aparece normalmente sobre uno o más operadores **Compute Scalar** sobre operadores **Constant Scan** , que construyen los intervalos (representados como columnas de una fila) que combina este operador. **Merge Interval** es un operador lógico y físico.| 
|![Icono del operador Merge Join](../relational-databases/media/merge-join-32x.gif "Icono del operador Merge Join")|**Merge Join**|El operador **Merge Join** realiza las siguientes operaciones lógicas de combinación interna (inner join), combinación externa izquierda (left outer join), semicombinación izquierda (left semi join), antisemicombinación izquierda (left anti semi join), combinación externa derecha (right outer join), semicombinación derecha (right semi join), antisemicombinación derecha (right anti semi join) y unión (union).<br /><br /> En la columna **Argument** , el operador **Merge Join** contiene un predicado MERGE:() si la operación realiza una combinación uno a varios, o un predicado MANY-TO-MANY MERGE:() si la operación realiza una combinación varios a varios. La columna **Argument** incluye una lista separada por comas de las columnas usadas para realizar la operación. El operador **Merge Join** requiere dos entradas ordenadas por sus respectivas columnas, que se pueden realizar mediante la inserción de operaciones de ordenación explícitas en el plan de consulta. El operador Merge Join es especialmente eficaz si no se necesita un orden explícito, por ejemplo, si hay un índice idóneo de árbol b en la base de datos o si el orden se puede aprovechar en varias operaciones, como en una combinación de mezcla y una agrupación con acumulación. **Merge Join** es un operador físico. Para obtener más información, vea [Comprender las combinaciones de mezcla](../relational-databases/performance/joins.md#merge).| 
|![Icono del operador Nested Loops](../relational-databases/media/nested-loops-32x.gif "Icono del operador Nested Loops")|**Nested Loops**|El operador **Nested Loops** realiza las operaciones lógicas de combinación interna, combinación externa izquierda, semicombinación izquierda y anti semicombinación. Las combinaciones de bucles anidados realizan una búsqueda en la tabla interna por cada fila de la tabla externa, normalmente mediante un índice. El procesador de consultas decide, en función de los costos anticipados, si debe ordenar o no la entrada externa para mejorar la ubicación de las búsquedas en el índice sobre la entrada interna. Se devuelven las filas que cumplen el predicado (opcional) de la columna **Argument** (como corresponda según la operación lógica que se realice). Cuando el atributo OPTIMIZED está establecido en **True**, significa que se usan bucles anidados optimizados (o una ordenación por lotes). **Nested Loops** es un operador físico. Para obtener más información, vea [Descripción de las combinaciones de bucles anidados](../relational-databases/performance/joins.md#nested_loops).| 
|![Icono del operador Nonclustered Index Delete](../relational-databases/media/nonclust-index-delete-32x.gif "Icono del operador Nonclustered Index Delete")|**Nonclustered Index Delete**|El operador **Nonclustered Index Delete** elimina las filas de entrada del índice no clúster especificado en la columna **Argument** . **Nonclustered Index Delete** es un operador físico.| 
|![Icono del operador Nonclustered Index Insert](../relational-databases/media/nonclust-index-insert-32x.gif "Icono del operador Nonclustered Index Insert")|**Index Insert**|El operador **Index Insert** inserta filas de su entrada en el índice no clúster especificado en la columna **Argument** . La columna **Argument** también contiene un predicado SET:(), que indica el valor en el que se establece cada columna. **Index Insert** es un operador físico.| 
|![Icono del operador Nonclustered Index Scan](../relational-databases/media/nonclustered-index-scan-32x.gif "Icono del operador Nonclustered Index Scan")|**Index Scan**|El operador **Index Scan** recupera todas las filas del índice no clúster especificadas en la columna **Argument** . Si aparece un predicado opcional WHERE:() en la columna **Argument** , solo se devuelven las filas que cumplen el predicado. **Index Scan** es un operador lógico y físico.| 
|![Icono del operador Nonclustered Index Seek](../relational-databases/media/index-seek-32x.gif "Icono del operador Nonclustered Index Seek")|**Index Seek**|El operador **Index Seek** usa la capacidad de búsqueda de los índices para recuperar filas de un índice no clúster. La columna **Argument** contiene el nombre del índice no clúster utilizado. También contiene el predicado SEEK:(). El motor de almacenamiento utiliza el índice para procesar solamente las filas que cumplen el predicado SEEK:(). También se puede incluir un predicado WHERE:(), predicado que evaluará el motor de almacenamiento respecto a todas las filas que cumplan el predicado SEEK:() (no se utilizan los índices para esta comprobación). Si la columna **Argument** contiene la cláusula ORDERED, significa que el procesador de consultas ha determinado que se deben devolver las filas en el orden en el que el índice no clúster las haya clasificado. Si no hay una cláusula ORDERED, el motor de almacenamiento busca el índice de la forma óptima (que no garantiza que el resultado se ordene). Permitir que el resultado mantenga su ordenación puede ser menos eficiente que generar un resultado no ordenado. **Index Seek** es un operador lógico y físico.| 
|![Icono del operador Nonclustered Index Spool](../relational-databases/media/index-spool-32x.gif "Icono del operador Nonclustered Index Spool")|**Index Spool**|El operador físico **Index Spool** contiene un predicado SEEK:() en la columna **Argument** . El operador **Index Spool** examina sus filas de entrada, coloca una copia de cada fila en un archivo de cola oculto (almacenado en la base de datos **tempdb** y que solo existe mientras dure la consulta) y genera un índice no agrupado en las filas. Esto permite utilizar la capacidad de búsqueda de los índices para presentar solo las filas que cumplan el predicado SEEK:(). Si se hace retroceder el operador (por ejemplo, con un operador **Nested Loops** ) pero no es necesario volver a enlazar, se usan los datos de la cola en lugar de volver a examinar la entrada.| 
|![Icono del operador Nonclustered Index Update](../relational-databases/media/nonclust-index-update-32x.gif "Icono del operador Nonclustered Index Update")|**Nonclustered Index Update**|El operador físico **Nonclustered Index Update** actualiza las filas de su entrada en el índice no clúster especificado en la columna **Argument** . Si hay un predicado SET:(), se asigna este valor a todas las filas actualizadas. **Nonclustered Index Update** es un operador físico.| 
|![Icono del operador Online Index Insert](../relational-databases/media/online-index-32x.gif "Icono del operador Online Index Insert")|**Online Index Insert**|El operador físico **Online Index Insert** indica que una operación de crear, modificar o colocar índice se realiza en línea. Es decir, los datos de la tabla subyacente permanecen disponible para los usuarios durante la operación de índice.| 
|None|**Paralelismo**|<a name="exchange"></a> El operador **Parallelism** (o iterador de intercambios) realiza las operaciones lógicas de distribución, recopilación y repartición de secuencias. Las columnas **Argument** pueden contener un predicado PARTITION COLUMNS:() con una lista separada por comas de las columnas que se van a particionar. Las columnas **Argument** también pueden contener un predicado ORDER BY:(), con una lista de las columnas que deben conservar el criterio de ordenación durante la creación de particiones. **Parallelism** es un operador físico. Para obtener más información sobre el operador Parallelism, vea la [serie del blog de Craig Freedman](/archive/blogs/craigfr/the-parallelism-operator-aka-exchange).<br /><br />**Nota:** Si una consulta se ha compilado como consulta paralela, pero en tiempo de ejecución se ejecuta como una consulta en serie, el resultado del plan de presentación generado por SET STATISTICS XML o mediante la opción **Incluir plan de ejecución real** de [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] no contendrá el elemento **RunTimeInformation** del operador **Parallelism**. En el resultado de SET STATISTICS PROFILE, el recuento real de filas y el número real de ejecuciones mostrará ceros para el operador **Parallelism** . Si se produce alguna de estas condiciones, significa que el operador **Parallelism** solo se ha usado durante la compilación de la consulta, y no en el plan de consulta en tiempo de ejecución. Tenga en cuenta que a veces los planes de consulta paralelos se ejecutan en serie si existe una elevada carga simultánea en el servidor.| 
|![Icono del operador Parameter Table Scan](../relational-databases/media/parameter-table-scan-32x.gif "Icono del operador Parameter Table Scan")|**Parameter Table Scan**|El operador **Parameter Table Scan** recorre una tabla que actúa como parámetro en la consulta actual. Normalmente, se usa para consultas INSERT en un procedimiento almacenado. **Parameter Table Scan** es un operador lógico y físico.| 
|None|**Partial Aggregate**|**Partial Aggregate** se usa en planes paralelos. Aplica una función de agregación a tantas filas de entrada como sea posible para que la escritura en el disco (también denominada "volcado") no sea necesaria. **Hash Match** es el único operador físico (iterador) que implementa el agregado de la partición. **Partial Aggregate** es un operador lógico.| 
|![Icono del operador de cursor Population Query](../relational-databases/media/poulation-query-32x.gif "Icono del operador de cursor Population Query")|**Population Query**|El operador **Population Query** rellena la tabla de trabajo de un cursor cuando se abre el cursor.| 
|![Icono del operador de cursor Refresh Query](../relational-databases/media/refresh-query-32x.gif "Icono del operador de cursor Refresh Query")|**Refresh Query**|El operador **Refresh Query** captura los datos actuales de las filas del búfer de lectura.| 
|![Icono del operador Remote Delete](../relational-databases/media/remote-delete-32x.gif "Icono del operador Remote Delete")|**Remote Delete**|El operador **Remote Delete** elimina las filas de entrada de un objeto remoto. **Remote Delete** es un operador lógico y físico.| 
|![Remote Index Scan (operador de Showplan)](../relational-databases/media/remote-index-scan-32x.gif "Remote Index Scan (operador de Showplan)")|**Remote Index Scan**|El operador **Remote Index Scan** digitaliza el índice remoto especificado en la columna Argument. **Remote Index Scan** es un operador lógico y físico.| 
|![Operador de plan de presentación Remote Index Seek](../relational-databases/media/remote-index-seek-32x.gif "Operador de plan de presentación Remote Index Seek")|**Remote Index Seek**|El operador **Remote Index Seek** usa la capacidad de búsqueda de un objeto de índice remoto para recuperar filas. La columna **Argument** contiene el nombre del índice remoto que se va a usar y el predicado SEEK:(). **Remote Index Seek** es un operador lógico y físico.| 
|![Icono del operador Remote Insert](../relational-databases/media/remote-insert-32x.gif "Icono del operador Remote Insert")|**Remote Insert**|El operador **Remote Insert** inserta las filas de entrada en un objeto remoto. **Remote Insert** es un operador lógico y físico.| 
|![Icono del operador Remote Query](../relational-databases/media/remote-query-32x.gif "Icono del operador Remote Query")|**Remote Query**|El operador **Remote Query** envía una consulta a un origen remoto. El texto de la consulta enviada al servidor remoto aparece en la columna **Argument** . **Remote Query** es un operador lógico y físico.| 
|![Icono del operador Remote Scan](../relational-databases/media/remote-scan-32x.gif "Icono del operador Remote Scan")|**Remote Scan**|El operador **Remote Scan** recorre un objeto remoto. El nombre del objeto remoto aparece en la columna **Argument** . **Remote Scan** es un operador lógico y físico.| 
|![Icono del operador Remote Update](../relational-databases/media/remote-update-32x.gif "Icono del operador Remote Update")|**Remote Update**|El operador **Remote Update** actualiza las filas de entrada en un objeto remoto. **Remote Update** es un operador lógico y físico.| 
|![Icono del operador de paralelismo Repartition Streams](../relational-databases/media/parallelism-repartition-stream.gif "Icono del operador de paralelismo Repartition Streams")|**Repartition Streams**|El operador (o iterador de intercambios) **Repartition Streams** usa varias secuencias y produce varias secuencias de registros. No se cambia el contenido de los registros ni su formato. Si el optimizador de consultas usa un filtro de mapas de bits, se reduce el número de filas del flujo de salida. Cada registro de un flujo de entrada se coloca en un flujo de salida. Si el operador conserva el orden, se deben ordenar y mezclar todos los flujos de entrada en varios flujos de salida ordenados. Si el resultado está dividido en particiones, la columna **Argument** contiene un predicado PARTITION COLUMNS:() y las columnas de particiones. Si el resultado está ordenado, la columna **Argument** contiene un predicado ORDER BY:() y las columnas que se ordenan. **Repartition Streams** es un operador lógico. Este operador solo se usa en los planes de consulta paralelos.| 
|![Icono del elemento del lenguaje Result](../relational-databases/media/result-32x.gif "Icono del elemento del lenguaje Result")|**Resultado**|El operador **Result** incluye los datos devueltos al final de un plan de consulta. Suele ser el elemento raíz de un plan de presentación. **Result** es un elemento del lenguaje.| 
|![Icono del operador RID Lookup](../relational-databases/media/rid-nonclust-locate-32x.gif "Icono del operador RID Lookup")|**RID Lookup**|**RID Lookup** es una búsqueda de marcadores en un montón que usa un identificador de fila suministrado (RID). La columna **Argument** contiene la etiqueta de marcador utilizada para buscar la fila en la tabla y el nombre de la tabla en la que se busca la fila. **RID Lookup** siempre va acompañado de NESTED LOOP JOIN. **RID Lookup** es un operador físico. Para obtener más información sobre las búsquedas por marcador, vea "[Bookmark Lookup](/archive/blogs/craigfr/)" (en inglés) en el blog de SQL Server en MSDN.| 
|![Icono del operador Row Count Spool](../relational-databases/media/remote-count-spool-32x.gif "Icono del operador Row Count Spool")|**Row Count Spool**|El operador **Row Count Spool** recorre la entrada, cuenta el número de filas que hay y devuelve ese número de filas sin datos. Este operador se utiliza cuando es importante comprobar la existencia de las filas, en lugar de los datos que éstas contienen. Por ejemplo, si un operador **Nested Loops** realiza una operación Left Semi Join y el predicado de combinación se aplica a la entrada interna, se puede colocar una cola de recuento de filas en la parte superior de la entrada interior del operador **Nested Loops** . Después, el operador **Nested Loops** puede calcular el número de filas que obtiene la cola de recuento de filas (dado que los datos reales del lado interno no son necesarios) para determinar si se devolverá la fila externa. **Row Count Spool** es un operador físico.| 
|None|**Right Anti Semi Join**|El operador **Right Anti Semi Join** muestra todas las filas de la segunda entrada (inferior) para las que no hay una fila coincidente en la primera entrada (superior). Una fila coincidente se define como aquella que cumple el predicado de la columna **Argument** (si no hay un predicado, cada fila es una fila coincidente). **Right Anti Semi Join** es un operador lógico.| 
|None|**Right Outer Join**|El operador **Right Outer Join** devuelve cada fila que cumple la combinación de la segunda entrada (inferior) con cada fila coincidente de la primera entrada (superior). También devolverá las filas de la segunda entrada que no tengan filas coincidentes en la primera entrada, combinadas con NULL (nulo). Si no hay ningún predicado de combinación en la columna **Argument** , cada fila es una fila coincidente. **Right Outer Join** es un operador lógico.| 
|None|**Right Semi Join**|El operador **Right Semi Join** devuelve todas las filas de la segunda entrada (inferior) para las que hay una fila coincidente en la primera entrada (superior). Si no hay ningún predicado de combinación en la columna **Argument** , cada fila es una fila coincidente. **Right Semi Join** es un operador lógico.| 
|![Icono del operador Segment](../relational-databases/media/segment-32x.gif "Icono del operador Segment")|**Segmento**|**Segment** es un operador físico y lógico. Divide el conjunto de entrada en segmentos basados en el valor de una o varias columnas. Estas columnas se muestran como argumentos en el operador **Segment** . A continuación, muestra un segmento cada vez.| 
|![Icono del operador Sequence](../relational-databases/media/sequence-32x.gif "Icono del operador Sequence")|**Secuencia**|El operador **Sequence** controla los planes de actualización grandes. Funcionalmente, ejecuta cada entrada en secuencia (de principio a fin). Normalmente, cada entrada es una actualización de un objeto diferente. Solo devuelve las filas que proceden de su última entrada (inferior). **Sequence** es un operador lógico y físico.| 
|![Icono del operador Sequence Project](../relational-databases/media/sequence-project-32x.gif "Icono del operador Sequence Project")|**Sequence Project**|El operador **Sequence Project** agrega columnas para realizar cálculos sobre un conjunto ordenado. Divide el conjunto de entrada en segmentos basados en el valor de una o varias columnas. A continuación, muestra un segmento cada vez. En el operador **Sequence Project** , las columnas se muestran como argumentos. **Sequence Project** es un operador lógico y físico.| 
|None|**Segment Repartition**|En un plan de consulta paralelo, a veces hay regiones conceptuales de iteradores. Todos los iteradores de una región así se pueden ejecutar mediante subprocesos paralelos. Las regiones en sí deben ejecutarse en serie. Algunos de los iteradores **Parallelism** de una región individual se denominan **Branch Repartition**. El iterador **Parallelism** situado en el límite de dos de estas regiones se denomina **Segment Repartition**. **Branch Repartition** y **Segment Repartition** son operadores lógicos.| 
|![Icono del operador de cursor Snapshot](../relational-databases/media/snapshot-32x.gif "Icono del operador de cursor Snapshot")|**Instantánea**|El operador **Snapshot** crea un cursor que no detecta las modificaciones realizadas por otros.| 
|![Icono del operador Sort](../relational-databases/media/sort-32x.gif "Icono del operador Sort")|**Sort**|El operador **Sort** ordena todas las filas entrantes. La columna **Argument** contiene un predicado DISTINCT ORDER BY:() si esta operación elimina las réplicas, o bien un predicado ORDER BY:() con una lista de las columnas, separadas por comas, que se van a ordenar. Las columnas llevan como prefijo el valor ASC, si el orden de las columnas es ascendente, o el valor DESC, si es descendente. **Sort** es un operador físico y lógico.| 
|![Icono del operador Split](../relational-databases/media/split-32x.gif "Icono del operador Split")|**Dividir**|El operador **Split** se utiliza para optimizar el procesamiento de actualizaciones. Divide cada operación de actualización en una operación de eliminación y una operación de inserción. **Split** es un operador lógico y físico.| 
|![Icono del operador Spool](../relational-databases/media/spool-32x.gif "Icono del operador Spool")|**Eager Spool**|El operador **Eager Spool** usa la entrada completa y almacena cada fila en un objeto temporal oculto almacenado en la base de datos **tempdb** . Si se hace retroceder el operador (por ejemplo, con un operador **Nested Loops** ) pero no es necesario volver a enlazar, se usan los datos de la cola en lugar de volver a examinar la entrada. Si es necesario volver a enlazar, se descartan los datos y se vuelve a generar el objeto de la cola; para ello se vuelve a recorrer la entrada (se vuelve a enlazar). El operador **Eager Spool** crea su archivo de cola de forma "ansiosa": cuando el operador primario de la cola solicita la primera fila, el operador de cola consume todas las filas de su operador de entrada y las almacena en la cola. **Eager Spool** es un operador lógico.| 
|![Icono del operador Spool](../relational-databases/media/spool-32x.gif "Icono del operador Spool")|**Lazy Spool**|El operador lógico **Lazy Spool** almacena cada fila de su entrada en un objeto temporal oculto almacenado en la base de datos **tempdb** . Si se hace retroceder el operador (por ejemplo, con un operador **Nested Loops** ) pero no es necesario volver a enlazar, se usan los datos de la cola en lugar de volver a examinar la entrada. Si es necesario volver a enlazar, se descartan los datos y se vuelve a generar el objeto de la cola; para ello se vuelve a recorrer la entrada (se vuelve a enlazar). El operador **Lazy Spool** crea su archivo de cola de un modo "perezoso", es decir, cada vez que el operador principal de la cola pide una fila, el operador de cola obtiene una fila de su operador de entrada y la almacena en la cola, en lugar de consumir todas las filas de una vez. Lazy Spool es un operador lógico.| 
|![Icono del operador Spool](../relational-databases/media/spool-32x.gif "Icono del operador Spool")|**Spool**|El operador **Spool** guarda un resultado de consulta intermedio en la base de datos **tempdb** .| 
|![Icono del operador Stream Aggregate](../relational-databases/media/stream-aggregate-32x.gif "Icono del operador Stream Aggregate")|**Stream Aggregate**|El operador **Stream Aggregate** agrupa las filas por una o varias columnas y, a continuación, calcula una o varias expresiones agregadas devueltas por la consulta. El resultado de este operador puedes ser utilizado por operadores posteriores de la consulta, devuelto al cliente, o ambas cosas. El operador **Stream Aggregate** requiere una entrada ordenada por las columnas dentro de sus grupos. El optimizador usará un operador **Sort** antes de este operador si un operador **Sort** anterior no ha ordenado ya los datos o debido a una búsqueda o recorrido de índice ordenado. En la instrucción SHOWPLAN_ALL o en el plan de ejecución gráfico de [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], las columnas del predicado GROUP BY se enumeran en la columna **Argument** y las expresiones agregadas se enumeran en la columna **Defined Values** . **Stream Aggregate** es un operador físico.| 
|![Icono del operador Switch](../relational-databases/media/switch-32x.gif "Icono del operador Switch")|**Switch**|**Switch** es un tipo especial de iterador de concatenación que tiene *n* entradas. A cada operador **Switch** se asocia una expresión. Dependiendo del valor devuelto de la expresión (entre 0 y *n*-1), **Switch** copia el flujo de entrada correspondiente en el flujo de salida. Un uso de **Switch** consiste en implementar planes de consulta en los que participan cursores de avance rápido con determinados operadores, como el operador **TOP** . **Switch** es un operador lógico y físico.| 
|![Icono del operador Table Delete](../relational-databases/media/table-delete-32x.gif "Icono del operador Table Delete")|**Table Delete**|El operador físico **Table Delete** elimina filas de la tabla especificada en la columna **Argument** del plan de ejecución de consulta.| 
|![Icono del operador Table Insert](../relational-databases/media/table-insert-32x.gif "Icono del operador Table Insert")|**Table Insert**|El operador **Table Insert** inserta filas de su entrada en la tabla especificada en la columna **Argument** del plan de ejecución de consulta. La columna **Argument** también contiene un predicado SET:(), que indica el valor en el que se establece cada columna. Si **Table Insert** no tiene elementos secundarios para los valores de inserción, se obtendrá la fila insertada del propio operador Insert. **Table Insert** es un operador físico.| 
|![Operador Table Merge](../relational-databases/media/table-merge-32x.gif "Operador Table Merge")|**Table Merge**|El operador **Table Merge** aplica un flujo de datos de mezcla a un montón. El operador elimina, actualiza o inserta filas en la tabla especificada en la columna **Argument** del operador. La operación real que se ejecuta depende del valor de tiempo de ejecución de la columna **ACTION** especificada en la columna **Argument** del operador. **Table Merge** es un operador físico.| 
|![Icono del operador Table Scan](../relational-databases/media/table-scan-32x.gif "Icono del operador Table Scan")|**Table Scan**|El operador **Table Scan** recupera todas las filas de la tabla especificada en la columna **Argument** del plan de ejecución de consulta. Si hay un predicado WHERE:() en la columna **Argument** , solo se devuelven las filas que cumplan el predicado. **Table Scan** es un operador lógico y físico.| 
|![Icono del operador Table Spool](../relational-databases/media/table-spool-32x.gif "Icono del operador Table Spool")|**Table Spool**|El operador **Table Spool** recorre la entrada y coloca una copia de cada fila en una tabla de cola oculta almacenada en la base de datos [tempdb](../relational-databases/databases/tempdb-database.md) y que solo existe durante la duración de la consulta. Si se hace retroceder el operador (por ejemplo, con un operador **Nested Loops** ) pero no es necesario volver a enlazar, se usan los datos de la cola en lugar de volver a examinar la entrada. **Table Spool** es un operador físico.| 
|![Icono del operador Table Spool](../relational-databases/media/table-spool-32x.gif "Icono del operador Table Spool")|**Window Spool**|El operador **Window Spool** expande cada fila del conjunto de filas que representa la ventana asociada con él. En una consulta, la cláusula OVER define la ventana de un conjunto de resultados de la consulta y, a continuación, una función de ventana calcula un valor para cada fila de la ventana. **Window Spool** es un operador lógico y físico.| 
|![Icono del operador Table Update](../relational-databases/media/table-update-32x.gif "Icono del operador Table Update")|**Table Update**|El operador físico **Table Update** actualiza las filas de entrada de la tabla especificada en la columna **Argument** del plan de ejecución de consulta. El predicado SET:() determina el valor de cada columna actualizada. Se puede hacer referencia a estos valores en la cláusula SET o en cualquier parte del operador, y en cualquier parte de esta consulta.| 
|![Icono del operador Table-valued Function](../relational-databases/media/table-valued-function-32x.gif "Icono del operador Table-valued Function")|**Table-valued Function**|El operador **Table-valued Function** evalúa una función con valores de tabla ( [!INCLUDE[tsql](../includes/tsql-md.md)] o CLR) y almacena las filas resultantes en la base de datos [tempdb](../relational-databases/databases/tempdb-database.md) . Cuando los iteradores principales solicitan las filas, **Table-valued Function** devuelve las filas desde **tempdb**.<br /><br /> Las consultas con llamadas a funciones con valores de tablas generan planes de consultas con el iterador de la **Table-valued Function** . **Table-valued Function** se puede evaluar con valores de parámetro diferentes:<br /><br /> -<br /> **Table-valued Function XML Reader** escribe un BLOB XML como parámetro y genera un conjunto de filas que representa los nodos XML en el orden del documento XML. Otros parámetros de entrada pueden restringir los nodos XML devueltos a un subconjunto del documento XML.<br /><br /> -**Table Valued Function XML Reader with XPath filter** es un tipo especial de **XML Reader Table-valued Function** que restringe la salida a los nodos XML que satisfacen una expresión XPath.<br /><br /> **Table-valued Function** es un operador lógico y físico.| 
|None|**Top N Sort**|**Top N Sort** es parecido al iterador **Sort** , excepto en que solo se necesitan las primeras *N* líneas, no todo el conjunto de resultados. Para valores pequeños de *N*, el motor de ejecución de consultas de [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] intenta realizar toda la operación de ordenación en memoria. Para valores grandes de *N*, el motor de ejecución de consultas recurre al método más genérico de ordenación, en el que *N* no es un parámetro.| 
|![Icono del operador Top](../relational-databases/media/top-32x.gif "Icono del operador Top")|**Top** (Principales)|El operador **Top** recorre la entrada y solo devuelve el primer número o porcentaje especificado de filas, basándose en un criterio de ordenación si es posible. Opcionalmente, la columna **Argument** puede contener una lista de las columnas en las que se comprueban los valores equivalentes. En los planes de actualización, se usa el operador **Top** para aplicar límites de recuento de filas. **Top** es un operador lógico y físico.| 
|![Icono del operador extendido (UDX)](../relational-databases/media/udx-32x.gif "Icono del operador extendido (UDX)")|**UDX**|Los operadores extendidos (UDX) implementan una de las múltiples operaciones XQuery y XPath de [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Todos los operadores UDX son operadores lógicos y físicos.<br /><br /> El operador extendido (UDX) **FOR XML** sirve para serializar el conjunto de filas relacional que introduce en la representación XML en una única columna BLOB de una única fila de salida. Es un operador de agregado XML que depende del orden.<br /><br /> El operador extendido (UDX) **XML SERIALIZER** es un operador de agregado XML que depende del orden. Especifica filas que representan nodos XML o valores escalares de XQuery en el orden del documento XML y produce un objeto BLOB XML serializado en una única columna XML de una única fila de salida.<br /><br /> El operador extendido (UDX) **XML FRAGMENT SERIALIZER** es un tipo especial de **XML SERIALIZER** que se usa para procesar filas de entrada que representan fragmentos XML que se insertan en la extensión de modificación de datos de inserción XQuery.<br /><br /> El operador extendido (UDX) **XQUERY STRING** evalúa el valor de cadena XQuery de las filas de entrada que representan nodos XML. Es un operador de agregado de cadena que depende del orden. Produce una fila con columnas que representa el valor escalar de XQuery que contiene el valor de cadena de la entrada.<br /><br /> El operador extendido (UDX) **XQUERY LIST DECOMPOSER** es un operador de descomposición de lista XQuery. Para cada fila de entrada que representa un nodo XML, produce una o varias filas, cada una de las cuales representa un valor escalar de XQuery que contiene un valor de elemento de lista si la entrada es de tipo lista XSD.<br /><br /> El operador extendido (UDX) **XQUERY DATA** evalúa la función XQuery fn:data() en la entrada que representa nodos XML. Es un operador de agregado de cadena que depende del orden. Genera una fila con columnas que representa el valor escalar de XQuery que contiene el resultado de **fn:data()** .<br /><br /> El operador extendido **XQUERY CONTAINS** evalúa la función XQuery fn:contains() en la entrada que representa nodos XML. Es un operador de agregado de cadena que depende del orden. Genera una fila con columnas que representa el valor escalar de XQuery que contiene el resultado de **fn:contains()** .<br /><br /> El operador extendido **UPDATE XML NODE** actualiza el nodo XML en la extensión de modificación de datos de reemplazo XQuery del método **modify()** en el tipo XML.| 
|None|**Unión**|El operador **Union** recorre varias entradas, obtiene cada fila recorrida y quita los duplicados. **Union** es un operador lógico.| 
|![Icono del operador Update (motor de base de datos)](../relational-databases/media/update-32x.gif "Icono del operador Update (motor de base de datos)")|**Actualizar**|El operador lógico **Update** actualiza cada fila a partir de su entrada en el objeto especificado en la columna **Argument** del plan de ejecución de consulta. **Update** es un operador lógico. El operador físico es **Table Update**, **Index Update** o **Clustered Index Update**.| 
|![Icono del elemento del lenguaje While](../relational-databases/media/while-32x.gif "Icono del elemento del lenguaje While")|**While**|El operador **While** implementa el bucle while de [!INCLUDE[tsql](../includes/tsql-md.md)] . **While** es un elemento del lenguaje| 
